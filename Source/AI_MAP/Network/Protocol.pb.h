// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_AIATTACK;
struct C_AIATTACKDefaultTypeInternal;
extern C_AIATTACKDefaultTypeInternal _C_AIATTACK_default_instance_;
class C_AIATTACK_BOSS2;
struct C_AIATTACK_BOSS2DefaultTypeInternal;
extern C_AIATTACK_BOSS2DefaultTypeInternal _C_AIATTACK_BOSS2_default_instance_;
class C_AIDAMAGED;
struct C_AIDAMAGEDDefaultTypeInternal;
extern C_AIDAMAGEDDefaultTypeInternal _C_AIDAMAGED_default_instance_;
class C_AIDEAD;
struct C_AIDEADDefaultTypeInternal;
extern C_AIDEADDefaultTypeInternal _C_AIDEAD_default_instance_;
class C_AIHIT;
struct C_AIHITDefaultTypeInternal;
extern C_AIHITDefaultTypeInternal _C_AIHIT_default_instance_;
class C_AIMOVE;
struct C_AIMOVEDefaultTypeInternal;
extern C_AIMOVEDefaultTypeInternal _C_AIMOVE_default_instance_;
class C_AIMOVESTOP;
struct C_AIMOVESTOPDefaultTypeInternal;
extern C_AIMOVESTOPDefaultTypeInternal _C_AIMOVESTOP_default_instance_;
class C_AIPROJSPAWN;
struct C_AIPROJSPAWNDefaultTypeInternal;
extern C_AIPROJSPAWNDefaultTypeInternal _C_AIPROJSPAWN_default_instance_;
class C_AIROTATE;
struct C_AIROTATEDefaultTypeInternal;
extern C_AIROTATEDefaultTypeInternal _C_AIROTATE_default_instance_;
class C_AISPAWN_BOSS;
struct C_AISPAWN_BOSSDefaultTypeInternal;
extern C_AISPAWN_BOSSDefaultTypeInternal _C_AISPAWN_BOSS_default_instance_;
class C_AISPAWN_PATROL;
struct C_AISPAWN_PATROLDefaultTypeInternal;
extern C_AISPAWN_PATROLDefaultTypeInternal _C_AISPAWN_PATROL_default_instance_;
class C_AISPAWN_RANDOM;
struct C_AISPAWN_RANDOMDefaultTypeInternal;
extern C_AISPAWN_RANDOMDefaultTypeInternal _C_AISPAWN_RANDOM_default_instance_;
class C_AI_KNOCKS_BACK;
struct C_AI_KNOCKS_BACKDefaultTypeInternal;
extern C_AI_KNOCKS_BACKDefaultTypeInternal _C_AI_KNOCKS_BACK_default_instance_;
class C_ATTACKDRONE;
struct C_ATTACKDRONEDefaultTypeInternal;
extern C_ATTACKDRONEDefaultTypeInternal _C_ATTACKDRONE_default_instance_;
class C_CHAT;
struct C_CHATDefaultTypeInternal;
extern C_CHATDefaultTypeInternal _C_CHAT_default_instance_;
class C_DAMAGED;
struct C_DAMAGEDDefaultTypeInternal;
extern C_DAMAGEDDefaultTypeInternal _C_DAMAGED_default_instance_;
class C_EATITEM_DMGUP;
struct C_EATITEM_DMGUPDefaultTypeInternal;
extern C_EATITEM_DMGUPDefaultTypeInternal _C_EATITEM_DMGUP_default_instance_;
class C_EATITEM_HEALHP;
struct C_EATITEM_HEALHPDefaultTypeInternal;
extern C_EATITEM_HEALHPDefaultTypeInternal _C_EATITEM_HEALHP_default_instance_;
class C_EATITEM_LVUP;
struct C_EATITEM_LVUPDefaultTypeInternal;
extern C_EATITEM_LVUPDefaultTypeInternal _C_EATITEM_LVUP_default_instance_;
class C_EATITEM_MAXHPUP;
struct C_EATITEM_MAXHPUPDefaultTypeInternal;
extern C_EATITEM_MAXHPUPDefaultTypeInternal _C_EATITEM_MAXHPUP_default_instance_;
class C_ENTER_GAME;
struct C_ENTER_GAMEDefaultTypeInternal;
extern C_ENTER_GAMEDefaultTypeInternal _C_ENTER_GAME_default_instance_;
class C_EXPUP;
struct C_EXPUPDefaultTypeInternal;
extern C_EXPUPDefaultTypeInternal _C_EXPUP_default_instance_;
class C_FIRE;
struct C_FIREDefaultTypeInternal;
extern C_FIREDefaultTypeInternal _C_FIRE_default_instance_;
class C_GAMERESULT;
struct C_GAMERESULTDefaultTypeInternal;
extern C_GAMERESULTDefaultTypeInternal _C_GAMERESULT_default_instance_;
class C_GAMESTART;
struct C_GAMESTARTDefaultTypeInternal;
extern C_GAMESTARTDefaultTypeInternal _C_GAMESTART_default_instance_;
class C_HIT;
struct C_HITDefaultTypeInternal;
extern C_HITDefaultTypeInternal _C_HIT_default_instance_;
class C_LEAVE_GAME;
struct C_LEAVE_GAMEDefaultTypeInternal;
extern C_LEAVE_GAMEDefaultTypeInternal _C_LEAVE_GAME_default_instance_;
class C_LOGIN;
struct C_LOGINDefaultTypeInternal;
extern C_LOGINDefaultTypeInternal _C_LOGIN_default_instance_;
class C_LVUP;
struct C_LVUPDefaultTypeInternal;
extern C_LVUPDefaultTypeInternal _C_LVUP_default_instance_;
class C_MAKEDRONE;
struct C_MAKEDRONEDefaultTypeInternal;
extern C_MAKEDRONEDefaultTypeInternal _C_MAKEDRONE_default_instance_;
class C_MOVE;
struct C_MOVEDefaultTypeInternal;
extern C_MOVEDefaultTypeInternal _C_MOVE_default_instance_;
class C_MOVEDRONE;
struct C_MOVEDRONEDefaultTypeInternal;
extern C_MOVEDRONEDefaultTypeInternal _C_MOVEDRONE_default_instance_;
class C_PLAYERCOUNT;
struct C_PLAYERCOUNTDefaultTypeInternal;
extern C_PLAYERCOUNTDefaultTypeInternal _C_PLAYERCOUNT_default_instance_;
class C_PLAYERDEAD;
struct C_PLAYERDEADDefaultTypeInternal;
extern C_PLAYERDEADDefaultTypeInternal _C_PLAYERDEAD_default_instance_;
class C_PLAYERHEAL;
struct C_PLAYERHEALDefaultTypeInternal;
extern C_PLAYERHEALDefaultTypeInternal _C_PLAYERHEAL_default_instance_;
class C_PLAYERSKILL_BOMB;
struct C_PLAYERSKILL_BOMBDefaultTypeInternal;
extern C_PLAYERSKILL_BOMBDefaultTypeInternal _C_PLAYERSKILL_BOMB_default_instance_;
class C_PLAYERSKILL_CHEMICAL;
struct C_PLAYERSKILL_CHEMICALDefaultTypeInternal;
extern C_PLAYERSKILL_CHEMICALDefaultTypeInternal _C_PLAYERSKILL_CHEMICAL_default_instance_;
class C_PLAYERSKILL_GRANADE;
struct C_PLAYERSKILL_GRANADEDefaultTypeInternal;
extern C_PLAYERSKILL_GRANADEDefaultTypeInternal _C_PLAYERSKILL_GRANADE_default_instance_;
class C_PLAYERSKILL_GUARD;
struct C_PLAYERSKILL_GUARDDefaultTypeInternal;
extern C_PLAYERSKILL_GUARDDefaultTypeInternal _C_PLAYERSKILL_GUARD_default_instance_;
class C_PLAYERSKILL_HEAL;
struct C_PLAYERSKILL_HEALDefaultTypeInternal;
extern C_PLAYERSKILL_HEALDefaultTypeInternal _C_PLAYERSKILL_HEAL_default_instance_;
class C_PLAYERSPAWNPOINT;
struct C_PLAYERSPAWNPOINTDefaultTypeInternal;
extern C_PLAYERSPAWNPOINTDefaultTypeInternal _C_PLAYERSPAWNPOINT_default_instance_;
class C_RETURNDRONE;
struct C_RETURNDRONEDefaultTypeInternal;
extern C_RETURNDRONEDefaultTypeInternal _C_RETURNDRONE_default_instance_;
class C_SEARCHDRONE;
struct C_SEARCHDRONEDefaultTypeInternal;
extern C_SEARCHDRONEDefaultTypeInternal _C_SEARCHDRONE_default_instance_;
class C_SET_MAGNETICFIELD;
struct C_SET_MAGNETICFIELDDefaultTypeInternal;
extern C_SET_MAGNETICFIELDDefaultTypeInternal _C_SET_MAGNETICFIELD_default_instance_;
class C_WORLD_LVUP;
struct C_WORLD_LVUPDefaultTypeInternal;
extern C_WORLD_LVUPDefaultTypeInternal _C_WORLD_LVUP_default_instance_;
class S_AIATTACK;
struct S_AIATTACKDefaultTypeInternal;
extern S_AIATTACKDefaultTypeInternal _S_AIATTACK_default_instance_;
class S_AIATTACK_BOSS2;
struct S_AIATTACK_BOSS2DefaultTypeInternal;
extern S_AIATTACK_BOSS2DefaultTypeInternal _S_AIATTACK_BOSS2_default_instance_;
class S_AIDAMAGED;
struct S_AIDAMAGEDDefaultTypeInternal;
extern S_AIDAMAGEDDefaultTypeInternal _S_AIDAMAGED_default_instance_;
class S_AIDEAD;
struct S_AIDEADDefaultTypeInternal;
extern S_AIDEADDefaultTypeInternal _S_AIDEAD_default_instance_;
class S_AIHIT;
struct S_AIHITDefaultTypeInternal;
extern S_AIHITDefaultTypeInternal _S_AIHIT_default_instance_;
class S_AIMOVE;
struct S_AIMOVEDefaultTypeInternal;
extern S_AIMOVEDefaultTypeInternal _S_AIMOVE_default_instance_;
class S_AIMOVESTOP;
struct S_AIMOVESTOPDefaultTypeInternal;
extern S_AIMOVESTOPDefaultTypeInternal _S_AIMOVESTOP_default_instance_;
class S_AIPROJSPAWN;
struct S_AIPROJSPAWNDefaultTypeInternal;
extern S_AIPROJSPAWNDefaultTypeInternal _S_AIPROJSPAWN_default_instance_;
class S_AIROTATE;
struct S_AIROTATEDefaultTypeInternal;
extern S_AIROTATEDefaultTypeInternal _S_AIROTATE_default_instance_;
class S_AISPAWN_BOSS;
struct S_AISPAWN_BOSSDefaultTypeInternal;
extern S_AISPAWN_BOSSDefaultTypeInternal _S_AISPAWN_BOSS_default_instance_;
class S_AISPAWN_PATROL;
struct S_AISPAWN_PATROLDefaultTypeInternal;
extern S_AISPAWN_PATROLDefaultTypeInternal _S_AISPAWN_PATROL_default_instance_;
class S_AISPAWN_RANDOM;
struct S_AISPAWN_RANDOMDefaultTypeInternal;
extern S_AISPAWN_RANDOMDefaultTypeInternal _S_AISPAWN_RANDOM_default_instance_;
class S_AI_KNOCKS_BACK;
struct S_AI_KNOCKS_BACKDefaultTypeInternal;
extern S_AI_KNOCKS_BACKDefaultTypeInternal _S_AI_KNOCKS_BACK_default_instance_;
class S_ATTACKDRONE;
struct S_ATTACKDRONEDefaultTypeInternal;
extern S_ATTACKDRONEDefaultTypeInternal _S_ATTACKDRONE_default_instance_;
class S_CHAT;
struct S_CHATDefaultTypeInternal;
extern S_CHATDefaultTypeInternal _S_CHAT_default_instance_;
class S_DAMAGED;
struct S_DAMAGEDDefaultTypeInternal;
extern S_DAMAGEDDefaultTypeInternal _S_DAMAGED_default_instance_;
class S_DESPAWN;
struct S_DESPAWNDefaultTypeInternal;
extern S_DESPAWNDefaultTypeInternal _S_DESPAWN_default_instance_;
class S_EATITEM_DMGUP;
struct S_EATITEM_DMGUPDefaultTypeInternal;
extern S_EATITEM_DMGUPDefaultTypeInternal _S_EATITEM_DMGUP_default_instance_;
class S_EATITEM_HEALHP;
struct S_EATITEM_HEALHPDefaultTypeInternal;
extern S_EATITEM_HEALHPDefaultTypeInternal _S_EATITEM_HEALHP_default_instance_;
class S_EATITEM_LVUP;
struct S_EATITEM_LVUPDefaultTypeInternal;
extern S_EATITEM_LVUPDefaultTypeInternal _S_EATITEM_LVUP_default_instance_;
class S_EATITEM_MAXHPUP;
struct S_EATITEM_MAXHPUPDefaultTypeInternal;
extern S_EATITEM_MAXHPUPDefaultTypeInternal _S_EATITEM_MAXHPUP_default_instance_;
class S_ENTER_GAME;
struct S_ENTER_GAMEDefaultTypeInternal;
extern S_ENTER_GAMEDefaultTypeInternal _S_ENTER_GAME_default_instance_;
class S_EXPUP;
struct S_EXPUPDefaultTypeInternal;
extern S_EXPUPDefaultTypeInternal _S_EXPUP_default_instance_;
class S_FIRE;
struct S_FIREDefaultTypeInternal;
extern S_FIREDefaultTypeInternal _S_FIRE_default_instance_;
class S_GAMERESULT;
struct S_GAMERESULTDefaultTypeInternal;
extern S_GAMERESULTDefaultTypeInternal _S_GAMERESULT_default_instance_;
class S_GAMESTART;
struct S_GAMESTARTDefaultTypeInternal;
extern S_GAMESTARTDefaultTypeInternal _S_GAMESTART_default_instance_;
class S_HIT;
struct S_HITDefaultTypeInternal;
extern S_HITDefaultTypeInternal _S_HIT_default_instance_;
class S_LEAVE_GAME;
struct S_LEAVE_GAMEDefaultTypeInternal;
extern S_LEAVE_GAMEDefaultTypeInternal _S_LEAVE_GAME_default_instance_;
class S_LOGIN;
struct S_LOGINDefaultTypeInternal;
extern S_LOGINDefaultTypeInternal _S_LOGIN_default_instance_;
class S_LVUP;
struct S_LVUPDefaultTypeInternal;
extern S_LVUPDefaultTypeInternal _S_LVUP_default_instance_;
class S_MAKEDRONE;
struct S_MAKEDRONEDefaultTypeInternal;
extern S_MAKEDRONEDefaultTypeInternal _S_MAKEDRONE_default_instance_;
class S_MOVE;
struct S_MOVEDefaultTypeInternal;
extern S_MOVEDefaultTypeInternal _S_MOVE_default_instance_;
class S_MOVEDRONE;
struct S_MOVEDRONEDefaultTypeInternal;
extern S_MOVEDRONEDefaultTypeInternal _S_MOVEDRONE_default_instance_;
class S_PLAYERCOUNT;
struct S_PLAYERCOUNTDefaultTypeInternal;
extern S_PLAYERCOUNTDefaultTypeInternal _S_PLAYERCOUNT_default_instance_;
class S_PLAYERDEAD;
struct S_PLAYERDEADDefaultTypeInternal;
extern S_PLAYERDEADDefaultTypeInternal _S_PLAYERDEAD_default_instance_;
class S_PLAYERHEAL;
struct S_PLAYERHEALDefaultTypeInternal;
extern S_PLAYERHEALDefaultTypeInternal _S_PLAYERHEAL_default_instance_;
class S_PLAYERSKILL_BOMB;
struct S_PLAYERSKILL_BOMBDefaultTypeInternal;
extern S_PLAYERSKILL_BOMBDefaultTypeInternal _S_PLAYERSKILL_BOMB_default_instance_;
class S_PLAYERSKILL_CHEMICAL;
struct S_PLAYERSKILL_CHEMICALDefaultTypeInternal;
extern S_PLAYERSKILL_CHEMICALDefaultTypeInternal _S_PLAYERSKILL_CHEMICAL_default_instance_;
class S_PLAYERSKILL_GRANADE;
struct S_PLAYERSKILL_GRANADEDefaultTypeInternal;
extern S_PLAYERSKILL_GRANADEDefaultTypeInternal _S_PLAYERSKILL_GRANADE_default_instance_;
class S_PLAYERSKILL_GUARD;
struct S_PLAYERSKILL_GUARDDefaultTypeInternal;
extern S_PLAYERSKILL_GUARDDefaultTypeInternal _S_PLAYERSKILL_GUARD_default_instance_;
class S_PLAYERSKILL_HEAL;
struct S_PLAYERSKILL_HEALDefaultTypeInternal;
extern S_PLAYERSKILL_HEALDefaultTypeInternal _S_PLAYERSKILL_HEAL_default_instance_;
class S_RETURNDRONE;
struct S_RETURNDRONEDefaultTypeInternal;
extern S_RETURNDRONEDefaultTypeInternal _S_RETURNDRONE_default_instance_;
class S_SEARCHDRONE;
struct S_SEARCHDRONEDefaultTypeInternal;
extern S_SEARCHDRONEDefaultTypeInternal _S_SEARCHDRONE_default_instance_;
class S_SET_MAGNETICFIELD;
struct S_SET_MAGNETICFIELDDefaultTypeInternal;
extern S_SET_MAGNETICFIELDDefaultTypeInternal _S_SET_MAGNETICFIELD_default_instance_;
class S_SPAWN;
struct S_SPAWNDefaultTypeInternal;
extern S_SPAWNDefaultTypeInternal _S_SPAWN_default_instance_;
class S_WORLD_LVUP;
struct S_WORLD_LVUPDefaultTypeInternal;
extern S_WORLD_LVUPDefaultTypeInternal _S_WORLD_LVUP_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_AIATTACK* Arena::CreateMaybeMessage<::Protocol::C_AIATTACK>(Arena*);
template<> ::Protocol::C_AIATTACK_BOSS2* Arena::CreateMaybeMessage<::Protocol::C_AIATTACK_BOSS2>(Arena*);
template<> ::Protocol::C_AIDAMAGED* Arena::CreateMaybeMessage<::Protocol::C_AIDAMAGED>(Arena*);
template<> ::Protocol::C_AIDEAD* Arena::CreateMaybeMessage<::Protocol::C_AIDEAD>(Arena*);
template<> ::Protocol::C_AIHIT* Arena::CreateMaybeMessage<::Protocol::C_AIHIT>(Arena*);
template<> ::Protocol::C_AIMOVE* Arena::CreateMaybeMessage<::Protocol::C_AIMOVE>(Arena*);
template<> ::Protocol::C_AIMOVESTOP* Arena::CreateMaybeMessage<::Protocol::C_AIMOVESTOP>(Arena*);
template<> ::Protocol::C_AIPROJSPAWN* Arena::CreateMaybeMessage<::Protocol::C_AIPROJSPAWN>(Arena*);
template<> ::Protocol::C_AIROTATE* Arena::CreateMaybeMessage<::Protocol::C_AIROTATE>(Arena*);
template<> ::Protocol::C_AISPAWN_BOSS* Arena::CreateMaybeMessage<::Protocol::C_AISPAWN_BOSS>(Arena*);
template<> ::Protocol::C_AISPAWN_PATROL* Arena::CreateMaybeMessage<::Protocol::C_AISPAWN_PATROL>(Arena*);
template<> ::Protocol::C_AISPAWN_RANDOM* Arena::CreateMaybeMessage<::Protocol::C_AISPAWN_RANDOM>(Arena*);
template<> ::Protocol::C_AI_KNOCKS_BACK* Arena::CreateMaybeMessage<::Protocol::C_AI_KNOCKS_BACK>(Arena*);
template<> ::Protocol::C_ATTACKDRONE* Arena::CreateMaybeMessage<::Protocol::C_ATTACKDRONE>(Arena*);
template<> ::Protocol::C_CHAT* Arena::CreateMaybeMessage<::Protocol::C_CHAT>(Arena*);
template<> ::Protocol::C_DAMAGED* Arena::CreateMaybeMessage<::Protocol::C_DAMAGED>(Arena*);
template<> ::Protocol::C_EATITEM_DMGUP* Arena::CreateMaybeMessage<::Protocol::C_EATITEM_DMGUP>(Arena*);
template<> ::Protocol::C_EATITEM_HEALHP* Arena::CreateMaybeMessage<::Protocol::C_EATITEM_HEALHP>(Arena*);
template<> ::Protocol::C_EATITEM_LVUP* Arena::CreateMaybeMessage<::Protocol::C_EATITEM_LVUP>(Arena*);
template<> ::Protocol::C_EATITEM_MAXHPUP* Arena::CreateMaybeMessage<::Protocol::C_EATITEM_MAXHPUP>(Arena*);
template<> ::Protocol::C_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::C_ENTER_GAME>(Arena*);
template<> ::Protocol::C_EXPUP* Arena::CreateMaybeMessage<::Protocol::C_EXPUP>(Arena*);
template<> ::Protocol::C_FIRE* Arena::CreateMaybeMessage<::Protocol::C_FIRE>(Arena*);
template<> ::Protocol::C_GAMERESULT* Arena::CreateMaybeMessage<::Protocol::C_GAMERESULT>(Arena*);
template<> ::Protocol::C_GAMESTART* Arena::CreateMaybeMessage<::Protocol::C_GAMESTART>(Arena*);
template<> ::Protocol::C_HIT* Arena::CreateMaybeMessage<::Protocol::C_HIT>(Arena*);
template<> ::Protocol::C_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::C_LEAVE_GAME>(Arena*);
template<> ::Protocol::C_LOGIN* Arena::CreateMaybeMessage<::Protocol::C_LOGIN>(Arena*);
template<> ::Protocol::C_LVUP* Arena::CreateMaybeMessage<::Protocol::C_LVUP>(Arena*);
template<> ::Protocol::C_MAKEDRONE* Arena::CreateMaybeMessage<::Protocol::C_MAKEDRONE>(Arena*);
template<> ::Protocol::C_MOVE* Arena::CreateMaybeMessage<::Protocol::C_MOVE>(Arena*);
template<> ::Protocol::C_MOVEDRONE* Arena::CreateMaybeMessage<::Protocol::C_MOVEDRONE>(Arena*);
template<> ::Protocol::C_PLAYERCOUNT* Arena::CreateMaybeMessage<::Protocol::C_PLAYERCOUNT>(Arena*);
template<> ::Protocol::C_PLAYERDEAD* Arena::CreateMaybeMessage<::Protocol::C_PLAYERDEAD>(Arena*);
template<> ::Protocol::C_PLAYERHEAL* Arena::CreateMaybeMessage<::Protocol::C_PLAYERHEAL>(Arena*);
template<> ::Protocol::C_PLAYERSKILL_BOMB* Arena::CreateMaybeMessage<::Protocol::C_PLAYERSKILL_BOMB>(Arena*);
template<> ::Protocol::C_PLAYERSKILL_CHEMICAL* Arena::CreateMaybeMessage<::Protocol::C_PLAYERSKILL_CHEMICAL>(Arena*);
template<> ::Protocol::C_PLAYERSKILL_GRANADE* Arena::CreateMaybeMessage<::Protocol::C_PLAYERSKILL_GRANADE>(Arena*);
template<> ::Protocol::C_PLAYERSKILL_GUARD* Arena::CreateMaybeMessage<::Protocol::C_PLAYERSKILL_GUARD>(Arena*);
template<> ::Protocol::C_PLAYERSKILL_HEAL* Arena::CreateMaybeMessage<::Protocol::C_PLAYERSKILL_HEAL>(Arena*);
template<> ::Protocol::C_PLAYERSPAWNPOINT* Arena::CreateMaybeMessage<::Protocol::C_PLAYERSPAWNPOINT>(Arena*);
template<> ::Protocol::C_RETURNDRONE* Arena::CreateMaybeMessage<::Protocol::C_RETURNDRONE>(Arena*);
template<> ::Protocol::C_SEARCHDRONE* Arena::CreateMaybeMessage<::Protocol::C_SEARCHDRONE>(Arena*);
template<> ::Protocol::C_SET_MAGNETICFIELD* Arena::CreateMaybeMessage<::Protocol::C_SET_MAGNETICFIELD>(Arena*);
template<> ::Protocol::C_WORLD_LVUP* Arena::CreateMaybeMessage<::Protocol::C_WORLD_LVUP>(Arena*);
template<> ::Protocol::S_AIATTACK* Arena::CreateMaybeMessage<::Protocol::S_AIATTACK>(Arena*);
template<> ::Protocol::S_AIATTACK_BOSS2* Arena::CreateMaybeMessage<::Protocol::S_AIATTACK_BOSS2>(Arena*);
template<> ::Protocol::S_AIDAMAGED* Arena::CreateMaybeMessage<::Protocol::S_AIDAMAGED>(Arena*);
template<> ::Protocol::S_AIDEAD* Arena::CreateMaybeMessage<::Protocol::S_AIDEAD>(Arena*);
template<> ::Protocol::S_AIHIT* Arena::CreateMaybeMessage<::Protocol::S_AIHIT>(Arena*);
template<> ::Protocol::S_AIMOVE* Arena::CreateMaybeMessage<::Protocol::S_AIMOVE>(Arena*);
template<> ::Protocol::S_AIMOVESTOP* Arena::CreateMaybeMessage<::Protocol::S_AIMOVESTOP>(Arena*);
template<> ::Protocol::S_AIPROJSPAWN* Arena::CreateMaybeMessage<::Protocol::S_AIPROJSPAWN>(Arena*);
template<> ::Protocol::S_AIROTATE* Arena::CreateMaybeMessage<::Protocol::S_AIROTATE>(Arena*);
template<> ::Protocol::S_AISPAWN_BOSS* Arena::CreateMaybeMessage<::Protocol::S_AISPAWN_BOSS>(Arena*);
template<> ::Protocol::S_AISPAWN_PATROL* Arena::CreateMaybeMessage<::Protocol::S_AISPAWN_PATROL>(Arena*);
template<> ::Protocol::S_AISPAWN_RANDOM* Arena::CreateMaybeMessage<::Protocol::S_AISPAWN_RANDOM>(Arena*);
template<> ::Protocol::S_AI_KNOCKS_BACK* Arena::CreateMaybeMessage<::Protocol::S_AI_KNOCKS_BACK>(Arena*);
template<> ::Protocol::S_ATTACKDRONE* Arena::CreateMaybeMessage<::Protocol::S_ATTACKDRONE>(Arena*);
template<> ::Protocol::S_CHAT* Arena::CreateMaybeMessage<::Protocol::S_CHAT>(Arena*);
template<> ::Protocol::S_DAMAGED* Arena::CreateMaybeMessage<::Protocol::S_DAMAGED>(Arena*);
template<> ::Protocol::S_DESPAWN* Arena::CreateMaybeMessage<::Protocol::S_DESPAWN>(Arena*);
template<> ::Protocol::S_EATITEM_DMGUP* Arena::CreateMaybeMessage<::Protocol::S_EATITEM_DMGUP>(Arena*);
template<> ::Protocol::S_EATITEM_HEALHP* Arena::CreateMaybeMessage<::Protocol::S_EATITEM_HEALHP>(Arena*);
template<> ::Protocol::S_EATITEM_LVUP* Arena::CreateMaybeMessage<::Protocol::S_EATITEM_LVUP>(Arena*);
template<> ::Protocol::S_EATITEM_MAXHPUP* Arena::CreateMaybeMessage<::Protocol::S_EATITEM_MAXHPUP>(Arena*);
template<> ::Protocol::S_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::S_ENTER_GAME>(Arena*);
template<> ::Protocol::S_EXPUP* Arena::CreateMaybeMessage<::Protocol::S_EXPUP>(Arena*);
template<> ::Protocol::S_FIRE* Arena::CreateMaybeMessage<::Protocol::S_FIRE>(Arena*);
template<> ::Protocol::S_GAMERESULT* Arena::CreateMaybeMessage<::Protocol::S_GAMERESULT>(Arena*);
template<> ::Protocol::S_GAMESTART* Arena::CreateMaybeMessage<::Protocol::S_GAMESTART>(Arena*);
template<> ::Protocol::S_HIT* Arena::CreateMaybeMessage<::Protocol::S_HIT>(Arena*);
template<> ::Protocol::S_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::S_LEAVE_GAME>(Arena*);
template<> ::Protocol::S_LOGIN* Arena::CreateMaybeMessage<::Protocol::S_LOGIN>(Arena*);
template<> ::Protocol::S_LVUP* Arena::CreateMaybeMessage<::Protocol::S_LVUP>(Arena*);
template<> ::Protocol::S_MAKEDRONE* Arena::CreateMaybeMessage<::Protocol::S_MAKEDRONE>(Arena*);
template<> ::Protocol::S_MOVE* Arena::CreateMaybeMessage<::Protocol::S_MOVE>(Arena*);
template<> ::Protocol::S_MOVEDRONE* Arena::CreateMaybeMessage<::Protocol::S_MOVEDRONE>(Arena*);
template<> ::Protocol::S_PLAYERCOUNT* Arena::CreateMaybeMessage<::Protocol::S_PLAYERCOUNT>(Arena*);
template<> ::Protocol::S_PLAYERDEAD* Arena::CreateMaybeMessage<::Protocol::S_PLAYERDEAD>(Arena*);
template<> ::Protocol::S_PLAYERHEAL* Arena::CreateMaybeMessage<::Protocol::S_PLAYERHEAL>(Arena*);
template<> ::Protocol::S_PLAYERSKILL_BOMB* Arena::CreateMaybeMessage<::Protocol::S_PLAYERSKILL_BOMB>(Arena*);
template<> ::Protocol::S_PLAYERSKILL_CHEMICAL* Arena::CreateMaybeMessage<::Protocol::S_PLAYERSKILL_CHEMICAL>(Arena*);
template<> ::Protocol::S_PLAYERSKILL_GRANADE* Arena::CreateMaybeMessage<::Protocol::S_PLAYERSKILL_GRANADE>(Arena*);
template<> ::Protocol::S_PLAYERSKILL_GUARD* Arena::CreateMaybeMessage<::Protocol::S_PLAYERSKILL_GUARD>(Arena*);
template<> ::Protocol::S_PLAYERSKILL_HEAL* Arena::CreateMaybeMessage<::Protocol::S_PLAYERSKILL_HEAL>(Arena*);
template<> ::Protocol::S_RETURNDRONE* Arena::CreateMaybeMessage<::Protocol::S_RETURNDRONE>(Arena*);
template<> ::Protocol::S_SEARCHDRONE* Arena::CreateMaybeMessage<::Protocol::S_SEARCHDRONE>(Arena*);
template<> ::Protocol::S_SET_MAGNETICFIELD* Arena::CreateMaybeMessage<::Protocol::S_SET_MAGNETICFIELD>(Arena*);
template<> ::Protocol::S_SPAWN* Arena::CreateMaybeMessage<::Protocol::S_SPAWN>(Arena*);
template<> ::Protocol::S_WORLD_LVUP* Arena::CreateMaybeMessage<::Protocol::S_WORLD_LVUP>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class C_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_LOGIN) */ {
 public:
  inline C_LOGIN() : C_LOGIN(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LOGIN(const C_LOGIN& from);
  C_LOGIN(C_LOGIN&& from) noexcept
    : C_LOGIN() {
    *this = ::std::move(from);
  }

  inline C_LOGIN& operator=(const C_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LOGIN& operator=(C_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LOGIN* internal_default_instance() {
    return reinterpret_cast<const C_LOGIN*>(
               &_C_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_LOGIN& a, C_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_LOGIN& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_LOGIN& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LOGIN";
  }
  protected:
  explicit C_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOGIN) */ {
 public:
  inline S_LOGIN() : S_LOGIN(nullptr) {}
  ~S_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR S_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOGIN(const S_LOGIN& from);
  S_LOGIN(S_LOGIN&& from) noexcept
    : S_LOGIN() {
    *this = ::std::move(from);
  }

  inline S_LOGIN& operator=(const S_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOGIN& operator=(S_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOGIN* internal_default_instance() {
    return reinterpret_cast<const S_LOGIN*>(
               &_S_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_LOGIN& a, S_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LOGIN& from) {
    S_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOGIN";
  }
  protected:
  explicit S_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIDFieldNumber = 1,
  };
  // uint64 client_ID = 1;
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t client_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PLAYERSPAWNPOINT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PLAYERSPAWNPOINT) */ {
 public:
  inline C_PLAYERSPAWNPOINT() : C_PLAYERSPAWNPOINT(nullptr) {}
  ~C_PLAYERSPAWNPOINT() override;
  explicit PROTOBUF_CONSTEXPR C_PLAYERSPAWNPOINT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PLAYERSPAWNPOINT(const C_PLAYERSPAWNPOINT& from);
  C_PLAYERSPAWNPOINT(C_PLAYERSPAWNPOINT&& from) noexcept
    : C_PLAYERSPAWNPOINT() {
    *this = ::std::move(from);
  }

  inline C_PLAYERSPAWNPOINT& operator=(const C_PLAYERSPAWNPOINT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PLAYERSPAWNPOINT& operator=(C_PLAYERSPAWNPOINT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PLAYERSPAWNPOINT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PLAYERSPAWNPOINT* internal_default_instance() {
    return reinterpret_cast<const C_PLAYERSPAWNPOINT*>(
               &_C_PLAYERSPAWNPOINT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(C_PLAYERSPAWNPOINT& a, C_PLAYERSPAWNPOINT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PLAYERSPAWNPOINT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PLAYERSPAWNPOINT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PLAYERSPAWNPOINT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PLAYERSPAWNPOINT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PLAYERSPAWNPOINT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PLAYERSPAWNPOINT& from) {
    C_PLAYERSPAWNPOINT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PLAYERSPAWNPOINT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PLAYERSPAWNPOINT";
  }
  protected:
  explicit C_PLAYERSPAWNPOINT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpawnPointSizeFieldNumber = 1,
  };
  // uint64 SpawnPointSize = 1;
  void clear_spawnpointsize();
  uint64_t spawnpointsize() const;
  void set_spawnpointsize(uint64_t value);
  private:
  uint64_t _internal_spawnpointsize() const;
  void _internal_set_spawnpointsize(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PLAYERSPAWNPOINT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t spawnpointsize_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PLAYERCOUNT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PLAYERCOUNT) */ {
 public:
  inline S_PLAYERCOUNT() : S_PLAYERCOUNT(nullptr) {}
  ~S_PLAYERCOUNT() override;
  explicit PROTOBUF_CONSTEXPR S_PLAYERCOUNT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PLAYERCOUNT(const S_PLAYERCOUNT& from);
  S_PLAYERCOUNT(S_PLAYERCOUNT&& from) noexcept
    : S_PLAYERCOUNT() {
    *this = ::std::move(from);
  }

  inline S_PLAYERCOUNT& operator=(const S_PLAYERCOUNT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PLAYERCOUNT& operator=(S_PLAYERCOUNT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PLAYERCOUNT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PLAYERCOUNT* internal_default_instance() {
    return reinterpret_cast<const S_PLAYERCOUNT*>(
               &_S_PLAYERCOUNT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_PLAYERCOUNT& a, S_PLAYERCOUNT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PLAYERCOUNT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PLAYERCOUNT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PLAYERCOUNT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PLAYERCOUNT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PLAYERCOUNT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PLAYERCOUNT& from) {
    S_PLAYERCOUNT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PLAYERCOUNT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PLAYERCOUNT";
  }
  protected:
  explicit S_PLAYERCOUNT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerCountFieldNumber = 1,
  };
  // uint64 playerCount = 1;
  void clear_playercount();
  uint64_t playercount() const;
  void set_playercount(uint64_t value);
  private:
  uint64_t _internal_playercount() const;
  void _internal_set_playercount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PLAYERCOUNT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t playercount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PLAYERCOUNT final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_PLAYERCOUNT) */ {
 public:
  inline C_PLAYERCOUNT() : C_PLAYERCOUNT(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_PLAYERCOUNT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PLAYERCOUNT(const C_PLAYERCOUNT& from);
  C_PLAYERCOUNT(C_PLAYERCOUNT&& from) noexcept
    : C_PLAYERCOUNT() {
    *this = ::std::move(from);
  }

  inline C_PLAYERCOUNT& operator=(const C_PLAYERCOUNT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PLAYERCOUNT& operator=(C_PLAYERCOUNT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PLAYERCOUNT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PLAYERCOUNT* internal_default_instance() {
    return reinterpret_cast<const C_PLAYERCOUNT*>(
               &_C_PLAYERCOUNT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_PLAYERCOUNT& a, C_PLAYERCOUNT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PLAYERCOUNT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PLAYERCOUNT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PLAYERCOUNT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PLAYERCOUNT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_PLAYERCOUNT& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_PLAYERCOUNT& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PLAYERCOUNT";
  }
  protected:
  explicit C_PLAYERCOUNT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_PLAYERCOUNT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_GAMESTART final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_GAMESTART) */ {
 public:
  inline C_GAMESTART() : C_GAMESTART(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_GAMESTART(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_GAMESTART(const C_GAMESTART& from);
  C_GAMESTART(C_GAMESTART&& from) noexcept
    : C_GAMESTART() {
    *this = ::std::move(from);
  }

  inline C_GAMESTART& operator=(const C_GAMESTART& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_GAMESTART& operator=(C_GAMESTART&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_GAMESTART& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_GAMESTART* internal_default_instance() {
    return reinterpret_cast<const C_GAMESTART*>(
               &_C_GAMESTART_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(C_GAMESTART& a, C_GAMESTART& b) {
    a.Swap(&b);
  }
  inline void Swap(C_GAMESTART* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_GAMESTART* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_GAMESTART* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_GAMESTART>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_GAMESTART& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_GAMESTART& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_GAMESTART";
  }
  protected:
  explicit C_GAMESTART(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_GAMESTART)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_GAMESTART final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_GAMESTART) */ {
 public:
  inline S_GAMESTART() : S_GAMESTART(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_GAMESTART(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_GAMESTART(const S_GAMESTART& from);
  S_GAMESTART(S_GAMESTART&& from) noexcept
    : S_GAMESTART() {
    *this = ::std::move(from);
  }

  inline S_GAMESTART& operator=(const S_GAMESTART& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_GAMESTART& operator=(S_GAMESTART&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_GAMESTART& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_GAMESTART* internal_default_instance() {
    return reinterpret_cast<const S_GAMESTART*>(
               &_S_GAMESTART_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(S_GAMESTART& a, S_GAMESTART& b) {
    a.Swap(&b);
  }
  inline void Swap(S_GAMESTART* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_GAMESTART* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_GAMESTART* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_GAMESTART>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_GAMESTART& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_GAMESTART& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_GAMESTART";
  }
  protected:
  explicit S_GAMESTART(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_GAMESTART)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ENTER_GAME) */ {
 public:
  inline C_ENTER_GAME() : C_ENTER_GAME(nullptr) {}
  ~C_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTER_GAME(const C_ENTER_GAME& from);
  C_ENTER_GAME(C_ENTER_GAME&& from) noexcept
    : C_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline C_ENTER_GAME& operator=(const C_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTER_GAME& operator=(C_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const C_ENTER_GAME*>(
               &_C_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(C_ENTER_GAME& a, C_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ENTER_GAME& from) {
    C_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENTER_GAME";
  }
  protected:
  explicit C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIDFieldNumber = 1,
  };
  // uint64 client_ID = 1;
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t client_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENTER_GAME) */ {
 public:
  inline S_ENTER_GAME() : S_ENTER_GAME(nullptr) {}
  ~S_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR S_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENTER_GAME(const S_ENTER_GAME& from);
  S_ENTER_GAME(S_ENTER_GAME&& from) noexcept
    : S_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline S_ENTER_GAME& operator=(const S_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENTER_GAME& operator=(S_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const S_ENTER_GAME*>(
               &_S_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_ENTER_GAME& a, S_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ENTER_GAME& from) {
    S_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENTER_GAME";
  }
  protected:
  explicit S_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
    kSpawnIdxFieldNumber = 2,
  };
  // .Protocol.ObjectInfo player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::ObjectInfo& player() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_player();
  ::Protocol::ObjectInfo* mutable_player();
  void set_allocated_player(::Protocol::ObjectInfo* player);
  private:
  const ::Protocol::ObjectInfo& _internal_player() const;
  ::Protocol::ObjectInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::ObjectInfo* player);
  ::Protocol::ObjectInfo* unsafe_arena_release_player();

  // uint64 spawnIdx = 2;
  void clear_spawnidx();
  uint64_t spawnidx() const;
  void set_spawnidx(uint64_t value);
  private:
  uint64_t _internal_spawnidx() const;
  void _internal_set_spawnidx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* player_;
    uint64_t spawnidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_LEAVE_GAME) */ {
 public:
  inline C_LEAVE_GAME() : C_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LEAVE_GAME(const C_LEAVE_GAME& from);
  C_LEAVE_GAME(C_LEAVE_GAME&& from) noexcept
    : C_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline C_LEAVE_GAME& operator=(const C_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LEAVE_GAME& operator=(C_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const C_LEAVE_GAME*>(
               &_C_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(C_LEAVE_GAME& a, C_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LEAVE_GAME";
  }
  protected:
  explicit C_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_LEAVE_GAME) */ {
 public:
  inline S_LEAVE_GAME() : S_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LEAVE_GAME(const S_LEAVE_GAME& from);
  S_LEAVE_GAME(S_LEAVE_GAME&& from) noexcept
    : S_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline S_LEAVE_GAME& operator=(const S_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LEAVE_GAME& operator=(S_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const S_LEAVE_GAME*>(
               &_S_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S_LEAVE_GAME& a, S_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LEAVE_GAME";
  }
  protected:
  explicit S_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SPAWN) */ {
 public:
  inline S_SPAWN() : S_SPAWN(nullptr) {}
  ~S_SPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SPAWN(const S_SPAWN& from);
  S_SPAWN(S_SPAWN&& from) noexcept
    : S_SPAWN() {
    *this = ::std::move(from);
  }

  inline S_SPAWN& operator=(const S_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SPAWN& operator=(S_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SPAWN* internal_default_instance() {
    return reinterpret_cast<const S_SPAWN*>(
               &_S_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_SPAWN& a, S_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SPAWN& from) {
    S_SPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SPAWN";
  }
  protected:
  explicit S_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
    kSpawnIdxFieldNumber = 2,
  };
  // repeated .Protocol.ObjectInfo players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::ObjectInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_players();
  private:
  const ::Protocol::ObjectInfo& _internal_players(int index) const;
  ::Protocol::ObjectInfo* _internal_add_players();
  public:
  const ::Protocol::ObjectInfo& players(int index) const;
  ::Protocol::ObjectInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      players() const;

  // uint64 spawnIdx = 2;
  void clear_spawnidx();
  uint64_t spawnidx() const;
  void set_spawnidx(uint64_t value);
  private:
  uint64_t _internal_spawnidx() const;
  void _internal_set_spawnidx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > players_;
    uint64_t spawnidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DESPAWN) */ {
 public:
  inline S_DESPAWN() : S_DESPAWN(nullptr) {}
  ~S_DESPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_DESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DESPAWN(const S_DESPAWN& from);
  S_DESPAWN(S_DESPAWN&& from) noexcept
    : S_DESPAWN() {
    *this = ::std::move(from);
  }

  inline S_DESPAWN& operator=(const S_DESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DESPAWN& operator=(S_DESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DESPAWN* internal_default_instance() {
    return reinterpret_cast<const S_DESPAWN*>(
               &_S_DESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_DESPAWN& a, S_DESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DESPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DESPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DESPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DESPAWN& from) {
    S_DESPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DESPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DESPAWN";
  }
  protected:
  explicit S_DESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
  };
  // repeated uint64 object_ids = 1;
  int object_ids_size() const;
  private:
  int _internal_object_ids_size() const;
  public:
  void clear_object_ids();
  private:
  uint64_t _internal_object_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_object_ids() const;
  void _internal_add_object_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_object_ids();
  public:
  uint64_t object_ids(int index) const;
  void set_object_ids(int index, uint64_t value);
  void add_object_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      object_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_object_ids();

  // @@protoc_insertion_point(class_scope:Protocol.S_DESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > object_ids_;
    mutable std::atomic<int> _object_ids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MOVE) */ {
 public:
  inline C_MOVE() : C_MOVE(nullptr) {}
  ~C_MOVE() override;
  explicit PROTOBUF_CONSTEXPR C_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MOVE(const C_MOVE& from);
  C_MOVE(C_MOVE&& from) noexcept
    : C_MOVE() {
    *this = ::std::move(from);
  }

  inline C_MOVE& operator=(const C_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MOVE& operator=(C_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MOVE* internal_default_instance() {
    return reinterpret_cast<const C_MOVE*>(
               &_C_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(C_MOVE& a, C_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MOVE& from) {
    C_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MOVE";
  }
  protected:
  explicit C_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.PosInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::PosInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_info();
  ::Protocol::PosInfo* mutable_info();
  void set_allocated_info(::Protocol::PosInfo* info);
  private:
  const ::Protocol::PosInfo& _internal_info() const;
  ::Protocol::PosInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::PosInfo* info);
  ::Protocol::PosInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.C_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PosInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MOVE) */ {
 public:
  inline S_MOVE() : S_MOVE(nullptr) {}
  ~S_MOVE() override;
  explicit PROTOBUF_CONSTEXPR S_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MOVE(const S_MOVE& from);
  S_MOVE(S_MOVE&& from) noexcept
    : S_MOVE() {
    *this = ::std::move(from);
  }

  inline S_MOVE& operator=(const S_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MOVE& operator=(S_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MOVE* internal_default_instance() {
    return reinterpret_cast<const S_MOVE*>(
               &_S_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_MOVE& a, S_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MOVE& from) {
    S_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MOVE";
  }
  protected:
  explicit S_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.PosInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::PosInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_info();
  ::Protocol::PosInfo* mutable_info();
  void set_allocated_info(::Protocol::PosInfo* info);
  private:
  const ::Protocol::PosInfo& _internal_info() const;
  ::Protocol::PosInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::PosInfo* info);
  ::Protocol::PosInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.S_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PosInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CHAT) */ {
 public:
  inline C_CHAT() : C_CHAT(nullptr) {}
  ~C_CHAT() override;
  explicit PROTOBUF_CONSTEXPR C_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CHAT(const C_CHAT& from);
  C_CHAT(C_CHAT&& from) noexcept
    : C_CHAT() {
    *this = ::std::move(from);
  }

  inline C_CHAT& operator=(const C_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CHAT& operator=(C_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CHAT* internal_default_instance() {
    return reinterpret_cast<const C_CHAT*>(
               &_C_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(C_CHAT& a, C_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CHAT& from) {
    C_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CHAT";
  }
  protected:
  explicit C_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHAT) */ {
 public:
  inline S_CHAT() : S_CHAT(nullptr) {}
  ~S_CHAT() override;
  explicit PROTOBUF_CONSTEXPR S_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHAT(const S_CHAT& from);
  S_CHAT(S_CHAT&& from) noexcept
    : S_CHAT() {
    *this = ::std::move(from);
  }

  inline S_CHAT& operator=(const S_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHAT& operator=(S_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHAT* internal_default_instance() {
    return reinterpret_cast<const S_CHAT*>(
               &_S_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_CHAT& a, S_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHAT& from) {
    S_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHAT";
  }
  protected:
  explicit S_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint64 playerId = 1;
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    uint64_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_FIRE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_FIRE) */ {
 public:
  inline C_FIRE() : C_FIRE(nullptr) {}
  ~C_FIRE() override;
  explicit PROTOBUF_CONSTEXPR C_FIRE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_FIRE(const C_FIRE& from);
  C_FIRE(C_FIRE&& from) noexcept
    : C_FIRE() {
    *this = ::std::move(from);
  }

  inline C_FIRE& operator=(const C_FIRE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_FIRE& operator=(C_FIRE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_FIRE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_FIRE* internal_default_instance() {
    return reinterpret_cast<const C_FIRE*>(
               &_C_FIRE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(C_FIRE& a, C_FIRE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_FIRE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_FIRE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_FIRE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_FIRE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_FIRE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_FIRE& from) {
    C_FIRE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_FIRE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_FIRE";
  }
  protected:
  explicit C_FIRE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectileFieldNumber = 1,
  };
  // .Protocol.ProjectileInfo projectile = 1;
  bool has_projectile() const;
  private:
  bool _internal_has_projectile() const;
  public:
  void clear_projectile();
  const ::Protocol::ProjectileInfo& projectile() const;
  PROTOBUF_NODISCARD ::Protocol::ProjectileInfo* release_projectile();
  ::Protocol::ProjectileInfo* mutable_projectile();
  void set_allocated_projectile(::Protocol::ProjectileInfo* projectile);
  private:
  const ::Protocol::ProjectileInfo& _internal_projectile() const;
  ::Protocol::ProjectileInfo* _internal_mutable_projectile();
  public:
  void unsafe_arena_set_allocated_projectile(
      ::Protocol::ProjectileInfo* projectile);
  ::Protocol::ProjectileInfo* unsafe_arena_release_projectile();

  // @@protoc_insertion_point(class_scope:Protocol.C_FIRE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ProjectileInfo* projectile_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_FIRE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_FIRE) */ {
 public:
  inline S_FIRE() : S_FIRE(nullptr) {}
  ~S_FIRE() override;
  explicit PROTOBUF_CONSTEXPR S_FIRE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_FIRE(const S_FIRE& from);
  S_FIRE(S_FIRE&& from) noexcept
    : S_FIRE() {
    *this = ::std::move(from);
  }

  inline S_FIRE& operator=(const S_FIRE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_FIRE& operator=(S_FIRE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_FIRE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_FIRE* internal_default_instance() {
    return reinterpret_cast<const S_FIRE*>(
               &_S_FIRE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_FIRE& a, S_FIRE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_FIRE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_FIRE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_FIRE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_FIRE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_FIRE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_FIRE& from) {
    S_FIRE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_FIRE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_FIRE";
  }
  protected:
  explicit S_FIRE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectileFieldNumber = 1,
  };
  // .Protocol.ProjectileInfo projectile = 1;
  bool has_projectile() const;
  private:
  bool _internal_has_projectile() const;
  public:
  void clear_projectile();
  const ::Protocol::ProjectileInfo& projectile() const;
  PROTOBUF_NODISCARD ::Protocol::ProjectileInfo* release_projectile();
  ::Protocol::ProjectileInfo* mutable_projectile();
  void set_allocated_projectile(::Protocol::ProjectileInfo* projectile);
  private:
  const ::Protocol::ProjectileInfo& _internal_projectile() const;
  ::Protocol::ProjectileInfo* _internal_mutable_projectile();
  public:
  void unsafe_arena_set_allocated_projectile(
      ::Protocol::ProjectileInfo* projectile);
  ::Protocol::ProjectileInfo* unsafe_arena_release_projectile();

  // @@protoc_insertion_point(class_scope:Protocol.S_FIRE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ProjectileInfo* projectile_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_HIT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_HIT) */ {
 public:
  inline C_HIT() : C_HIT(nullptr) {}
  ~C_HIT() override;
  explicit PROTOBUF_CONSTEXPR C_HIT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_HIT(const C_HIT& from);
  C_HIT(C_HIT&& from) noexcept
    : C_HIT() {
    *this = ::std::move(from);
  }

  inline C_HIT& operator=(const C_HIT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_HIT& operator=(C_HIT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_HIT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_HIT* internal_default_instance() {
    return reinterpret_cast<const C_HIT*>(
               &_C_HIT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(C_HIT& a, C_HIT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_HIT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_HIT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_HIT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_HIT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_HIT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_HIT& from) {
    C_HIT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_HIT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_HIT";
  }
  protected:
  explicit C_HIT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kDamageFieldNumber = 3,
  };
  // uint64 ownerId = 1;
  void clear_ownerid();
  uint64_t ownerid() const;
  void set_ownerid(uint64_t value);
  private:
  uint64_t _internal_ownerid() const;
  void _internal_set_ownerid(uint64_t value);
  public:

  // uint64 targetId = 2;
  void clear_targetid();
  uint64_t targetid() const;
  void set_targetid(uint64_t value);
  private:
  uint64_t _internal_targetid() const;
  void _internal_set_targetid(uint64_t value);
  public:

  // float damage = 3;
  void clear_damage();
  float damage() const;
  void set_damage(float value);
  private:
  float _internal_damage() const;
  void _internal_set_damage(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_HIT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t ownerid_;
    uint64_t targetid_;
    float damage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_HIT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_HIT) */ {
 public:
  inline S_HIT() : S_HIT(nullptr) {}
  ~S_HIT() override;
  explicit PROTOBUF_CONSTEXPR S_HIT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_HIT(const S_HIT& from);
  S_HIT(S_HIT&& from) noexcept
    : S_HIT() {
    *this = ::std::move(from);
  }

  inline S_HIT& operator=(const S_HIT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_HIT& operator=(S_HIT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_HIT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_HIT* internal_default_instance() {
    return reinterpret_cast<const S_HIT*>(
               &_S_HIT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(S_HIT& a, S_HIT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_HIT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_HIT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_HIT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_HIT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_HIT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_HIT& from) {
    S_HIT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_HIT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_HIT";
  }
  protected:
  explicit S_HIT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kDamageFieldNumber = 3,
  };
  // uint64 ownerId = 1;
  void clear_ownerid();
  uint64_t ownerid() const;
  void set_ownerid(uint64_t value);
  private:
  uint64_t _internal_ownerid() const;
  void _internal_set_ownerid(uint64_t value);
  public:

  // uint64 targetId = 2;
  void clear_targetid();
  uint64_t targetid() const;
  void set_targetid(uint64_t value);
  private:
  uint64_t _internal_targetid() const;
  void _internal_set_targetid(uint64_t value);
  public:

  // float damage = 3;
  void clear_damage();
  float damage() const;
  void set_damage(float value);
  private:
  float _internal_damage() const;
  void _internal_set_damage(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_HIT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t ownerid_;
    uint64_t targetid_;
    float damage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EXPUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EXPUP) */ {
 public:
  inline S_EXPUP() : S_EXPUP(nullptr) {}
  ~S_EXPUP() override;
  explicit PROTOBUF_CONSTEXPR S_EXPUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EXPUP(const S_EXPUP& from);
  S_EXPUP(S_EXPUP&& from) noexcept
    : S_EXPUP() {
    *this = ::std::move(from);
  }

  inline S_EXPUP& operator=(const S_EXPUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EXPUP& operator=(S_EXPUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EXPUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EXPUP* internal_default_instance() {
    return reinterpret_cast<const S_EXPUP*>(
               &_S_EXPUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(S_EXPUP& a, S_EXPUP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EXPUP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EXPUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EXPUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EXPUP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EXPUP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EXPUP& from) {
    S_EXPUP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EXPUP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EXPUP";
  }
  protected:
  explicit S_EXPUP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerIdFieldNumber = 1,
    kExpFieldNumber = 2,
  };
  // uint64 ownerId = 1;
  void clear_ownerid();
  uint64_t ownerid() const;
  void set_ownerid(uint64_t value);
  private:
  uint64_t _internal_ownerid() const;
  void _internal_set_ownerid(uint64_t value);
  public:

  // float exp = 2;
  void clear_exp();
  float exp() const;
  void set_exp(float value);
  private:
  float _internal_exp() const;
  void _internal_set_exp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EXPUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t ownerid_;
    float exp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EXPUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EXPUP) */ {
 public:
  inline C_EXPUP() : C_EXPUP(nullptr) {}
  ~C_EXPUP() override;
  explicit PROTOBUF_CONSTEXPR C_EXPUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EXPUP(const C_EXPUP& from);
  C_EXPUP(C_EXPUP&& from) noexcept
    : C_EXPUP() {
    *this = ::std::move(from);
  }

  inline C_EXPUP& operator=(const C_EXPUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EXPUP& operator=(C_EXPUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EXPUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EXPUP* internal_default_instance() {
    return reinterpret_cast<const C_EXPUP*>(
               &_C_EXPUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(C_EXPUP& a, C_EXPUP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EXPUP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EXPUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EXPUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EXPUP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EXPUP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_EXPUP& from) {
    C_EXPUP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EXPUP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EXPUP";
  }
  protected:
  explicit C_EXPUP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerIdFieldNumber = 1,
    kExpFieldNumber = 2,
  };
  // uint64 ownerId = 1;
  void clear_ownerid();
  uint64_t ownerid() const;
  void set_ownerid(uint64_t value);
  private:
  uint64_t _internal_ownerid() const;
  void _internal_set_ownerid(uint64_t value);
  public:

  // float exp = 2;
  void clear_exp();
  float exp() const;
  void set_exp(float value);
  private:
  float _internal_exp() const;
  void _internal_set_exp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EXPUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t ownerid_;
    float exp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LVUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LVUP) */ {
 public:
  inline S_LVUP() : S_LVUP(nullptr) {}
  ~S_LVUP() override;
  explicit PROTOBUF_CONSTEXPR S_LVUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LVUP(const S_LVUP& from);
  S_LVUP(S_LVUP&& from) noexcept
    : S_LVUP() {
    *this = ::std::move(from);
  }

  inline S_LVUP& operator=(const S_LVUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LVUP& operator=(S_LVUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LVUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LVUP* internal_default_instance() {
    return reinterpret_cast<const S_LVUP*>(
               &_S_LVUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(S_LVUP& a, S_LVUP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LVUP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LVUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LVUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LVUP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LVUP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LVUP& from) {
    S_LVUP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LVUP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LVUP";
  }
  protected:
  explicit S_LVUP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerIdFieldNumber = 1,
    kLevelFieldNumber = 3,
    kCurrExpFieldNumber = 2,
  };
  // uint64 ownerId = 1;
  void clear_ownerid();
  uint64_t ownerid() const;
  void set_ownerid(uint64_t value);
  private:
  uint64_t _internal_ownerid() const;
  void _internal_set_ownerid(uint64_t value);
  public:

  // int64 level = 3;
  void clear_level();
  int64_t level() const;
  void set_level(int64_t value);
  private:
  int64_t _internal_level() const;
  void _internal_set_level(int64_t value);
  public:

  // float currExp = 2;
  void clear_currexp();
  float currexp() const;
  void set_currexp(float value);
  private:
  float _internal_currexp() const;
  void _internal_set_currexp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LVUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t ownerid_;
    int64_t level_;
    float currexp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LVUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LVUP) */ {
 public:
  inline C_LVUP() : C_LVUP(nullptr) {}
  ~C_LVUP() override;
  explicit PROTOBUF_CONSTEXPR C_LVUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LVUP(const C_LVUP& from);
  C_LVUP(C_LVUP&& from) noexcept
    : C_LVUP() {
    *this = ::std::move(from);
  }

  inline C_LVUP& operator=(const C_LVUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LVUP& operator=(C_LVUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LVUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LVUP* internal_default_instance() {
    return reinterpret_cast<const C_LVUP*>(
               &_C_LVUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(C_LVUP& a, C_LVUP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LVUP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LVUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LVUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LVUP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LVUP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_LVUP& from) {
    C_LVUP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LVUP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LVUP";
  }
  protected:
  explicit C_LVUP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerIdFieldNumber = 1,
    kLevelFieldNumber = 3,
    kCurrExpFieldNumber = 2,
  };
  // uint64 ownerId = 1;
  void clear_ownerid();
  uint64_t ownerid() const;
  void set_ownerid(uint64_t value);
  private:
  uint64_t _internal_ownerid() const;
  void _internal_set_ownerid(uint64_t value);
  public:

  // int64 level = 3;
  void clear_level();
  int64_t level() const;
  void set_level(int64_t value);
  private:
  int64_t _internal_level() const;
  void _internal_set_level(int64_t value);
  public:

  // float currExp = 2;
  void clear_currexp();
  float currexp() const;
  void set_currexp(float value);
  private:
  float _internal_currexp() const;
  void _internal_set_currexp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LVUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t ownerid_;
    int64_t level_;
    float currexp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AISPAWN_RANDOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AISPAWN_RANDOM) */ {
 public:
  inline C_AISPAWN_RANDOM() : C_AISPAWN_RANDOM(nullptr) {}
  ~C_AISPAWN_RANDOM() override;
  explicit PROTOBUF_CONSTEXPR C_AISPAWN_RANDOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AISPAWN_RANDOM(const C_AISPAWN_RANDOM& from);
  C_AISPAWN_RANDOM(C_AISPAWN_RANDOM&& from) noexcept
    : C_AISPAWN_RANDOM() {
    *this = ::std::move(from);
  }

  inline C_AISPAWN_RANDOM& operator=(const C_AISPAWN_RANDOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AISPAWN_RANDOM& operator=(C_AISPAWN_RANDOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AISPAWN_RANDOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AISPAWN_RANDOM* internal_default_instance() {
    return reinterpret_cast<const C_AISPAWN_RANDOM*>(
               &_C_AISPAWN_RANDOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(C_AISPAWN_RANDOM& a, C_AISPAWN_RANDOM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AISPAWN_RANDOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AISPAWN_RANDOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AISPAWN_RANDOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AISPAWN_RANDOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AISPAWN_RANDOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AISPAWN_RANDOM& from) {
    C_AISPAWN_RANDOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AISPAWN_RANDOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AISPAWN_RANDOM";
  }
  protected:
  explicit C_AISPAWN_RANDOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kContainerIdxFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 container_Idx = 2;
  void clear_container_idx();
  uint64_t container_idx() const;
  void set_container_idx(uint64_t value);
  private:
  uint64_t _internal_container_idx() const;
  void _internal_set_container_idx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AISPAWN_RANDOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t container_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AISPAWN_RANDOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AISPAWN_RANDOM) */ {
 public:
  inline S_AISPAWN_RANDOM() : S_AISPAWN_RANDOM(nullptr) {}
  ~S_AISPAWN_RANDOM() override;
  explicit PROTOBUF_CONSTEXPR S_AISPAWN_RANDOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AISPAWN_RANDOM(const S_AISPAWN_RANDOM& from);
  S_AISPAWN_RANDOM(S_AISPAWN_RANDOM&& from) noexcept
    : S_AISPAWN_RANDOM() {
    *this = ::std::move(from);
  }

  inline S_AISPAWN_RANDOM& operator=(const S_AISPAWN_RANDOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AISPAWN_RANDOM& operator=(S_AISPAWN_RANDOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AISPAWN_RANDOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AISPAWN_RANDOM* internal_default_instance() {
    return reinterpret_cast<const S_AISPAWN_RANDOM*>(
               &_S_AISPAWN_RANDOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(S_AISPAWN_RANDOM& a, S_AISPAWN_RANDOM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AISPAWN_RANDOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AISPAWN_RANDOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AISPAWN_RANDOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AISPAWN_RANDOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AISPAWN_RANDOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AISPAWN_RANDOM& from) {
    S_AISPAWN_RANDOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AISPAWN_RANDOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AISPAWN_RANDOM";
  }
  protected:
  explicit S_AISPAWN_RANDOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kContainerIdxFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 container_Idx = 2;
  void clear_container_idx();
  uint64_t container_idx() const;
  void set_container_idx(uint64_t value);
  private:
  uint64_t _internal_container_idx() const;
  void _internal_set_container_idx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AISPAWN_RANDOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t container_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AISPAWN_PATROL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AISPAWN_PATROL) */ {
 public:
  inline C_AISPAWN_PATROL() : C_AISPAWN_PATROL(nullptr) {}
  ~C_AISPAWN_PATROL() override;
  explicit PROTOBUF_CONSTEXPR C_AISPAWN_PATROL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AISPAWN_PATROL(const C_AISPAWN_PATROL& from);
  C_AISPAWN_PATROL(C_AISPAWN_PATROL&& from) noexcept
    : C_AISPAWN_PATROL() {
    *this = ::std::move(from);
  }

  inline C_AISPAWN_PATROL& operator=(const C_AISPAWN_PATROL& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AISPAWN_PATROL& operator=(C_AISPAWN_PATROL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AISPAWN_PATROL& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AISPAWN_PATROL* internal_default_instance() {
    return reinterpret_cast<const C_AISPAWN_PATROL*>(
               &_C_AISPAWN_PATROL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(C_AISPAWN_PATROL& a, C_AISPAWN_PATROL& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AISPAWN_PATROL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AISPAWN_PATROL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AISPAWN_PATROL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AISPAWN_PATROL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AISPAWN_PATROL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AISPAWN_PATROL& from) {
    C_AISPAWN_PATROL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AISPAWN_PATROL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AISPAWN_PATROL";
  }
  protected:
  explicit C_AISPAWN_PATROL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kContainerIdxFieldNumber = 2,
    kPointIdxFieldNumber = 3,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 container_Idx = 2;
  void clear_container_idx();
  uint64_t container_idx() const;
  void set_container_idx(uint64_t value);
  private:
  uint64_t _internal_container_idx() const;
  void _internal_set_container_idx(uint64_t value);
  public:

  // uint64 pointIdx = 3;
  void clear_pointidx();
  uint64_t pointidx() const;
  void set_pointidx(uint64_t value);
  private:
  uint64_t _internal_pointidx() const;
  void _internal_set_pointidx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AISPAWN_PATROL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t container_idx_;
    uint64_t pointidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AISPAWN_PATROL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AISPAWN_PATROL) */ {
 public:
  inline S_AISPAWN_PATROL() : S_AISPAWN_PATROL(nullptr) {}
  ~S_AISPAWN_PATROL() override;
  explicit PROTOBUF_CONSTEXPR S_AISPAWN_PATROL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AISPAWN_PATROL(const S_AISPAWN_PATROL& from);
  S_AISPAWN_PATROL(S_AISPAWN_PATROL&& from) noexcept
    : S_AISPAWN_PATROL() {
    *this = ::std::move(from);
  }

  inline S_AISPAWN_PATROL& operator=(const S_AISPAWN_PATROL& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AISPAWN_PATROL& operator=(S_AISPAWN_PATROL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AISPAWN_PATROL& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AISPAWN_PATROL* internal_default_instance() {
    return reinterpret_cast<const S_AISPAWN_PATROL*>(
               &_S_AISPAWN_PATROL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(S_AISPAWN_PATROL& a, S_AISPAWN_PATROL& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AISPAWN_PATROL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AISPAWN_PATROL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AISPAWN_PATROL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AISPAWN_PATROL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AISPAWN_PATROL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AISPAWN_PATROL& from) {
    S_AISPAWN_PATROL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AISPAWN_PATROL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AISPAWN_PATROL";
  }
  protected:
  explicit S_AISPAWN_PATROL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kContainerIdxFieldNumber = 2,
    kPointIdxFieldNumber = 3,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 container_Idx = 2;
  void clear_container_idx();
  uint64_t container_idx() const;
  void set_container_idx(uint64_t value);
  private:
  uint64_t _internal_container_idx() const;
  void _internal_set_container_idx(uint64_t value);
  public:

  // uint64 pointIdx = 3;
  void clear_pointidx();
  uint64_t pointidx() const;
  void set_pointidx(uint64_t value);
  private:
  uint64_t _internal_pointidx() const;
  void _internal_set_pointidx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AISPAWN_PATROL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t container_idx_;
    uint64_t pointidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AISPAWN_BOSS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AISPAWN_BOSS) */ {
 public:
  inline C_AISPAWN_BOSS() : C_AISPAWN_BOSS(nullptr) {}
  ~C_AISPAWN_BOSS() override;
  explicit PROTOBUF_CONSTEXPR C_AISPAWN_BOSS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AISPAWN_BOSS(const C_AISPAWN_BOSS& from);
  C_AISPAWN_BOSS(C_AISPAWN_BOSS&& from) noexcept
    : C_AISPAWN_BOSS() {
    *this = ::std::move(from);
  }

  inline C_AISPAWN_BOSS& operator=(const C_AISPAWN_BOSS& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AISPAWN_BOSS& operator=(C_AISPAWN_BOSS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AISPAWN_BOSS& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AISPAWN_BOSS* internal_default_instance() {
    return reinterpret_cast<const C_AISPAWN_BOSS*>(
               &_C_AISPAWN_BOSS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(C_AISPAWN_BOSS& a, C_AISPAWN_BOSS& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AISPAWN_BOSS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AISPAWN_BOSS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AISPAWN_BOSS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AISPAWN_BOSS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AISPAWN_BOSS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AISPAWN_BOSS& from) {
    C_AISPAWN_BOSS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AISPAWN_BOSS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AISPAWN_BOSS";
  }
  protected:
  explicit C_AISPAWN_BOSS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kContainerIdxFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 container_Idx = 2;
  void clear_container_idx();
  uint64_t container_idx() const;
  void set_container_idx(uint64_t value);
  private:
  uint64_t _internal_container_idx() const;
  void _internal_set_container_idx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AISPAWN_BOSS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t container_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AISPAWN_BOSS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AISPAWN_BOSS) */ {
 public:
  inline S_AISPAWN_BOSS() : S_AISPAWN_BOSS(nullptr) {}
  ~S_AISPAWN_BOSS() override;
  explicit PROTOBUF_CONSTEXPR S_AISPAWN_BOSS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AISPAWN_BOSS(const S_AISPAWN_BOSS& from);
  S_AISPAWN_BOSS(S_AISPAWN_BOSS&& from) noexcept
    : S_AISPAWN_BOSS() {
    *this = ::std::move(from);
  }

  inline S_AISPAWN_BOSS& operator=(const S_AISPAWN_BOSS& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AISPAWN_BOSS& operator=(S_AISPAWN_BOSS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AISPAWN_BOSS& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AISPAWN_BOSS* internal_default_instance() {
    return reinterpret_cast<const S_AISPAWN_BOSS*>(
               &_S_AISPAWN_BOSS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(S_AISPAWN_BOSS& a, S_AISPAWN_BOSS& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AISPAWN_BOSS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AISPAWN_BOSS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AISPAWN_BOSS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AISPAWN_BOSS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AISPAWN_BOSS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AISPAWN_BOSS& from) {
    S_AISPAWN_BOSS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AISPAWN_BOSS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AISPAWN_BOSS";
  }
  protected:
  explicit S_AISPAWN_BOSS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kContainerIdxFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 container_Idx = 2;
  void clear_container_idx();
  uint64_t container_idx() const;
  void set_container_idx(uint64_t value);
  private:
  uint64_t _internal_container_idx() const;
  void _internal_set_container_idx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AISPAWN_BOSS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t container_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AIMOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AIMOVE) */ {
 public:
  inline S_AIMOVE() : S_AIMOVE(nullptr) {}
  ~S_AIMOVE() override;
  explicit PROTOBUF_CONSTEXPR S_AIMOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AIMOVE(const S_AIMOVE& from);
  S_AIMOVE(S_AIMOVE&& from) noexcept
    : S_AIMOVE() {
    *this = ::std::move(from);
  }

  inline S_AIMOVE& operator=(const S_AIMOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AIMOVE& operator=(S_AIMOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AIMOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AIMOVE* internal_default_instance() {
    return reinterpret_cast<const S_AIMOVE*>(
               &_S_AIMOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(S_AIMOVE& a, S_AIMOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AIMOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AIMOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AIMOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AIMOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AIMOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AIMOVE& from) {
    S_AIMOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AIMOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AIMOVE";
  }
  protected:
  explicit S_AIMOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.PosInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::PosInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_info();
  ::Protocol::PosInfo* mutable_info();
  void set_allocated_info(::Protocol::PosInfo* info);
  private:
  const ::Protocol::PosInfo& _internal_info() const;
  ::Protocol::PosInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::PosInfo* info);
  ::Protocol::PosInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.S_AIMOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PosInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AIMOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AIMOVE) */ {
 public:
  inline C_AIMOVE() : C_AIMOVE(nullptr) {}
  ~C_AIMOVE() override;
  explicit PROTOBUF_CONSTEXPR C_AIMOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AIMOVE(const C_AIMOVE& from);
  C_AIMOVE(C_AIMOVE&& from) noexcept
    : C_AIMOVE() {
    *this = ::std::move(from);
  }

  inline C_AIMOVE& operator=(const C_AIMOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AIMOVE& operator=(C_AIMOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AIMOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AIMOVE* internal_default_instance() {
    return reinterpret_cast<const C_AIMOVE*>(
               &_C_AIMOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(C_AIMOVE& a, C_AIMOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AIMOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AIMOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AIMOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AIMOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AIMOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AIMOVE& from) {
    C_AIMOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AIMOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AIMOVE";
  }
  protected:
  explicit C_AIMOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.PosInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::PosInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::PosInfo* release_info();
  ::Protocol::PosInfo* mutable_info();
  void set_allocated_info(::Protocol::PosInfo* info);
  private:
  const ::Protocol::PosInfo& _internal_info() const;
  ::Protocol::PosInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::PosInfo* info);
  ::Protocol::PosInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.C_AIMOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PosInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AIMOVESTOP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AIMOVESTOP) */ {
 public:
  inline S_AIMOVESTOP() : S_AIMOVESTOP(nullptr) {}
  ~S_AIMOVESTOP() override;
  explicit PROTOBUF_CONSTEXPR S_AIMOVESTOP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AIMOVESTOP(const S_AIMOVESTOP& from);
  S_AIMOVESTOP(S_AIMOVESTOP&& from) noexcept
    : S_AIMOVESTOP() {
    *this = ::std::move(from);
  }

  inline S_AIMOVESTOP& operator=(const S_AIMOVESTOP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AIMOVESTOP& operator=(S_AIMOVESTOP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AIMOVESTOP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AIMOVESTOP* internal_default_instance() {
    return reinterpret_cast<const S_AIMOVESTOP*>(
               &_S_AIMOVESTOP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(S_AIMOVESTOP& a, S_AIMOVESTOP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AIMOVESTOP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AIMOVESTOP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AIMOVESTOP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AIMOVESTOP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AIMOVESTOP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AIMOVESTOP& from) {
    S_AIMOVESTOP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AIMOVESTOP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AIMOVESTOP";
  }
  protected:
  explicit S_AIMOVESTOP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kSpeedFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float speed = 2;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AIMOVESTOP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AIMOVESTOP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AIMOVESTOP) */ {
 public:
  inline C_AIMOVESTOP() : C_AIMOVESTOP(nullptr) {}
  ~C_AIMOVESTOP() override;
  explicit PROTOBUF_CONSTEXPR C_AIMOVESTOP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AIMOVESTOP(const C_AIMOVESTOP& from);
  C_AIMOVESTOP(C_AIMOVESTOP&& from) noexcept
    : C_AIMOVESTOP() {
    *this = ::std::move(from);
  }

  inline C_AIMOVESTOP& operator=(const C_AIMOVESTOP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AIMOVESTOP& operator=(C_AIMOVESTOP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AIMOVESTOP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AIMOVESTOP* internal_default_instance() {
    return reinterpret_cast<const C_AIMOVESTOP*>(
               &_C_AIMOVESTOP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(C_AIMOVESTOP& a, C_AIMOVESTOP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AIMOVESTOP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AIMOVESTOP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AIMOVESTOP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AIMOVESTOP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AIMOVESTOP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AIMOVESTOP& from) {
    C_AIMOVESTOP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AIMOVESTOP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AIMOVESTOP";
  }
  protected:
  explicit C_AIMOVESTOP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kSpeedFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float speed = 2;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AIMOVESTOP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AIATTACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AIATTACK) */ {
 public:
  inline S_AIATTACK() : S_AIATTACK(nullptr) {}
  ~S_AIATTACK() override;
  explicit PROTOBUF_CONSTEXPR S_AIATTACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AIATTACK(const S_AIATTACK& from);
  S_AIATTACK(S_AIATTACK&& from) noexcept
    : S_AIATTACK() {
    *this = ::std::move(from);
  }

  inline S_AIATTACK& operator=(const S_AIATTACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AIATTACK& operator=(S_AIATTACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AIATTACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AIATTACK* internal_default_instance() {
    return reinterpret_cast<const S_AIATTACK*>(
               &_S_AIATTACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(S_AIATTACK& a, S_AIATTACK& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AIATTACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AIATTACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AIATTACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AIATTACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AIATTACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AIATTACK& from) {
    S_AIATTACK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AIATTACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AIATTACK";
  }
  protected:
  explicit S_AIATTACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAttackIdxFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 attack_idx = 2;
  void clear_attack_idx();
  uint64_t attack_idx() const;
  void set_attack_idx(uint64_t value);
  private:
  uint64_t _internal_attack_idx() const;
  void _internal_set_attack_idx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AIATTACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t attack_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AIATTACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AIATTACK) */ {
 public:
  inline C_AIATTACK() : C_AIATTACK(nullptr) {}
  ~C_AIATTACK() override;
  explicit PROTOBUF_CONSTEXPR C_AIATTACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AIATTACK(const C_AIATTACK& from);
  C_AIATTACK(C_AIATTACK&& from) noexcept
    : C_AIATTACK() {
    *this = ::std::move(from);
  }

  inline C_AIATTACK& operator=(const C_AIATTACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AIATTACK& operator=(C_AIATTACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AIATTACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AIATTACK* internal_default_instance() {
    return reinterpret_cast<const C_AIATTACK*>(
               &_C_AIATTACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(C_AIATTACK& a, C_AIATTACK& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AIATTACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AIATTACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AIATTACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AIATTACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AIATTACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AIATTACK& from) {
    C_AIATTACK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AIATTACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AIATTACK";
  }
  protected:
  explicit C_AIATTACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAttackIdxFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 attack_idx = 2;
  void clear_attack_idx();
  uint64_t attack_idx() const;
  void set_attack_idx(uint64_t value);
  private:
  uint64_t _internal_attack_idx() const;
  void _internal_set_attack_idx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AIATTACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t attack_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AIATTACK_BOSS2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AIATTACK_BOSS2) */ {
 public:
  inline S_AIATTACK_BOSS2() : S_AIATTACK_BOSS2(nullptr) {}
  ~S_AIATTACK_BOSS2() override;
  explicit PROTOBUF_CONSTEXPR S_AIATTACK_BOSS2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AIATTACK_BOSS2(const S_AIATTACK_BOSS2& from);
  S_AIATTACK_BOSS2(S_AIATTACK_BOSS2&& from) noexcept
    : S_AIATTACK_BOSS2() {
    *this = ::std::move(from);
  }

  inline S_AIATTACK_BOSS2& operator=(const S_AIATTACK_BOSS2& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AIATTACK_BOSS2& operator=(S_AIATTACK_BOSS2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AIATTACK_BOSS2& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AIATTACK_BOSS2* internal_default_instance() {
    return reinterpret_cast<const S_AIATTACK_BOSS2*>(
               &_S_AIATTACK_BOSS2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(S_AIATTACK_BOSS2& a, S_AIATTACK_BOSS2& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AIATTACK_BOSS2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AIATTACK_BOSS2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AIATTACK_BOSS2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AIATTACK_BOSS2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AIATTACK_BOSS2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AIATTACK_BOSS2& from) {
    S_AIATTACK_BOSS2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AIATTACK_BOSS2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AIATTACK_BOSS2";
  }
  protected:
  explicit S_AIATTACK_BOSS2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetIdFieldNumber = 2,
    kObjectIdFieldNumber = 1,
  };
  // repeated uint64 target_id = 2;
  int target_id_size() const;
  private:
  int _internal_target_id_size() const;
  public:
  void clear_target_id();
  private:
  uint64_t _internal_target_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_target_id() const;
  void _internal_add_target_id(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_target_id();
  public:
  uint64_t target_id(int index) const;
  void set_target_id(int index, uint64_t value);
  void add_target_id(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      target_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_target_id();

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AIATTACK_BOSS2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > target_id_;
    mutable std::atomic<int> _target_id_cached_byte_size_;
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AIATTACK_BOSS2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AIATTACK_BOSS2) */ {
 public:
  inline C_AIATTACK_BOSS2() : C_AIATTACK_BOSS2(nullptr) {}
  ~C_AIATTACK_BOSS2() override;
  explicit PROTOBUF_CONSTEXPR C_AIATTACK_BOSS2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AIATTACK_BOSS2(const C_AIATTACK_BOSS2& from);
  C_AIATTACK_BOSS2(C_AIATTACK_BOSS2&& from) noexcept
    : C_AIATTACK_BOSS2() {
    *this = ::std::move(from);
  }

  inline C_AIATTACK_BOSS2& operator=(const C_AIATTACK_BOSS2& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AIATTACK_BOSS2& operator=(C_AIATTACK_BOSS2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AIATTACK_BOSS2& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AIATTACK_BOSS2* internal_default_instance() {
    return reinterpret_cast<const C_AIATTACK_BOSS2*>(
               &_C_AIATTACK_BOSS2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(C_AIATTACK_BOSS2& a, C_AIATTACK_BOSS2& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AIATTACK_BOSS2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AIATTACK_BOSS2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AIATTACK_BOSS2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AIATTACK_BOSS2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AIATTACK_BOSS2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AIATTACK_BOSS2& from) {
    C_AIATTACK_BOSS2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AIATTACK_BOSS2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AIATTACK_BOSS2";
  }
  protected:
  explicit C_AIATTACK_BOSS2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetIdFieldNumber = 2,
    kObjectIdFieldNumber = 1,
  };
  // repeated uint64 target_id = 2;
  int target_id_size() const;
  private:
  int _internal_target_id_size() const;
  public:
  void clear_target_id();
  private:
  uint64_t _internal_target_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_target_id() const;
  void _internal_add_target_id(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_target_id();
  public:
  uint64_t target_id(int index) const;
  void set_target_id(int index, uint64_t value);
  void add_target_id(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      target_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_target_id();

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AIATTACK_BOSS2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > target_id_;
    mutable std::atomic<int> _target_id_cached_byte_size_;
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AIROTATE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AIROTATE) */ {
 public:
  inline S_AIROTATE() : S_AIROTATE(nullptr) {}
  ~S_AIROTATE() override;
  explicit PROTOBUF_CONSTEXPR S_AIROTATE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AIROTATE(const S_AIROTATE& from);
  S_AIROTATE(S_AIROTATE&& from) noexcept
    : S_AIROTATE() {
    *this = ::std::move(from);
  }

  inline S_AIROTATE& operator=(const S_AIROTATE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AIROTATE& operator=(S_AIROTATE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AIROTATE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AIROTATE* internal_default_instance() {
    return reinterpret_cast<const S_AIROTATE*>(
               &_S_AIROTATE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(S_AIROTATE& a, S_AIROTATE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AIROTATE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AIROTATE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AIROTATE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AIROTATE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AIROTATE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AIROTATE& from) {
    S_AIROTATE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AIROTATE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AIROTATE";
  }
  protected:
  explicit S_AIROTATE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kYawFieldNumber = 2,
    kPitchFieldNumber = 3,
    kRollFieldNumber = 4,
    kXFieldNumber = 5,
    kYFieldNumber = 6,
    kZFieldNumber = 7,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float yaw = 2;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float pitch = 3;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 4;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // float x = 5;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 6;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 7;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AIROTATE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float yaw_;
    float pitch_;
    float roll_;
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AIROTATE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AIROTATE) */ {
 public:
  inline C_AIROTATE() : C_AIROTATE(nullptr) {}
  ~C_AIROTATE() override;
  explicit PROTOBUF_CONSTEXPR C_AIROTATE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AIROTATE(const C_AIROTATE& from);
  C_AIROTATE(C_AIROTATE&& from) noexcept
    : C_AIROTATE() {
    *this = ::std::move(from);
  }

  inline C_AIROTATE& operator=(const C_AIROTATE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AIROTATE& operator=(C_AIROTATE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AIROTATE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AIROTATE* internal_default_instance() {
    return reinterpret_cast<const C_AIROTATE*>(
               &_C_AIROTATE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(C_AIROTATE& a, C_AIROTATE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AIROTATE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AIROTATE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AIROTATE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AIROTATE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AIROTATE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AIROTATE& from) {
    C_AIROTATE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AIROTATE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AIROTATE";
  }
  protected:
  explicit C_AIROTATE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kYawFieldNumber = 2,
    kPitchFieldNumber = 3,
    kRollFieldNumber = 4,
    kXFieldNumber = 5,
    kYFieldNumber = 6,
    kZFieldNumber = 7,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float yaw = 2;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float pitch = 3;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 4;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // float x = 5;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 6;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 7;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AIROTATE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float yaw_;
    float pitch_;
    float roll_;
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AIHIT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AIHIT) */ {
 public:
  inline S_AIHIT() : S_AIHIT(nullptr) {}
  ~S_AIHIT() override;
  explicit PROTOBUF_CONSTEXPR S_AIHIT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AIHIT(const S_AIHIT& from);
  S_AIHIT(S_AIHIT&& from) noexcept
    : S_AIHIT() {
    *this = ::std::move(from);
  }

  inline S_AIHIT& operator=(const S_AIHIT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AIHIT& operator=(S_AIHIT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AIHIT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AIHIT* internal_default_instance() {
    return reinterpret_cast<const S_AIHIT*>(
               &_S_AIHIT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(S_AIHIT& a, S_AIHIT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AIHIT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AIHIT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AIHIT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AIHIT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AIHIT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AIHIT& from) {
    S_AIHIT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AIHIT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AIHIT";
  }
  protected:
  explicit S_AIHIT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AIHIT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AIHIT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AIHIT) */ {
 public:
  inline C_AIHIT() : C_AIHIT(nullptr) {}
  ~C_AIHIT() override;
  explicit PROTOBUF_CONSTEXPR C_AIHIT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AIHIT(const C_AIHIT& from);
  C_AIHIT(C_AIHIT&& from) noexcept
    : C_AIHIT() {
    *this = ::std::move(from);
  }

  inline C_AIHIT& operator=(const C_AIHIT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AIHIT& operator=(C_AIHIT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AIHIT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AIHIT* internal_default_instance() {
    return reinterpret_cast<const C_AIHIT*>(
               &_C_AIHIT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(C_AIHIT& a, C_AIHIT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AIHIT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AIHIT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AIHIT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AIHIT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AIHIT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AIHIT& from) {
    C_AIHIT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AIHIT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AIHIT";
  }
  protected:
  explicit C_AIHIT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AIHIT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DAMAGED final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DAMAGED) */ {
 public:
  inline S_DAMAGED() : S_DAMAGED(nullptr) {}
  ~S_DAMAGED() override;
  explicit PROTOBUF_CONSTEXPR S_DAMAGED(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DAMAGED(const S_DAMAGED& from);
  S_DAMAGED(S_DAMAGED&& from) noexcept
    : S_DAMAGED() {
    *this = ::std::move(from);
  }

  inline S_DAMAGED& operator=(const S_DAMAGED& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DAMAGED& operator=(S_DAMAGED&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DAMAGED& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DAMAGED* internal_default_instance() {
    return reinterpret_cast<const S_DAMAGED*>(
               &_S_DAMAGED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(S_DAMAGED& a, S_DAMAGED& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DAMAGED* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DAMAGED* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DAMAGED* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DAMAGED>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DAMAGED& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DAMAGED& from) {
    S_DAMAGED::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DAMAGED* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DAMAGED";
  }
  protected:
  explicit S_DAMAGED(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kHpFieldNumber = 2,
    kGuardPointFieldNumber = 3,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float hp = 2;
  void clear_hp();
  float hp() const;
  void set_hp(float value);
  private:
  float _internal_hp() const;
  void _internal_set_hp(float value);
  public:

  // float guardPoint = 3;
  void clear_guardpoint();
  float guardpoint() const;
  void set_guardpoint(float value);
  private:
  float _internal_guardpoint() const;
  void _internal_set_guardpoint(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_DAMAGED)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float hp_;
    float guardpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_DAMAGED final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_DAMAGED) */ {
 public:
  inline C_DAMAGED() : C_DAMAGED(nullptr) {}
  ~C_DAMAGED() override;
  explicit PROTOBUF_CONSTEXPR C_DAMAGED(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_DAMAGED(const C_DAMAGED& from);
  C_DAMAGED(C_DAMAGED&& from) noexcept
    : C_DAMAGED() {
    *this = ::std::move(from);
  }

  inline C_DAMAGED& operator=(const C_DAMAGED& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_DAMAGED& operator=(C_DAMAGED&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_DAMAGED& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_DAMAGED* internal_default_instance() {
    return reinterpret_cast<const C_DAMAGED*>(
               &_C_DAMAGED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(C_DAMAGED& a, C_DAMAGED& b) {
    a.Swap(&b);
  }
  inline void Swap(C_DAMAGED* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_DAMAGED* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_DAMAGED* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_DAMAGED>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_DAMAGED& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_DAMAGED& from) {
    C_DAMAGED::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_DAMAGED* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_DAMAGED";
  }
  protected:
  explicit C_DAMAGED(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kHpFieldNumber = 2,
    kGuardPointFieldNumber = 3,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float hp = 2;
  void clear_hp();
  float hp() const;
  void set_hp(float value);
  private:
  float _internal_hp() const;
  void _internal_set_hp(float value);
  public:

  // float guardPoint = 3;
  void clear_guardpoint();
  float guardpoint() const;
  void set_guardpoint(float value);
  private:
  float _internal_guardpoint() const;
  void _internal_set_guardpoint(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_DAMAGED)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float hp_;
    float guardpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AIDAMAGED final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AIDAMAGED) */ {
 public:
  inline S_AIDAMAGED() : S_AIDAMAGED(nullptr) {}
  ~S_AIDAMAGED() override;
  explicit PROTOBUF_CONSTEXPR S_AIDAMAGED(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AIDAMAGED(const S_AIDAMAGED& from);
  S_AIDAMAGED(S_AIDAMAGED&& from) noexcept
    : S_AIDAMAGED() {
    *this = ::std::move(from);
  }

  inline S_AIDAMAGED& operator=(const S_AIDAMAGED& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AIDAMAGED& operator=(S_AIDAMAGED&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AIDAMAGED& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AIDAMAGED* internal_default_instance() {
    return reinterpret_cast<const S_AIDAMAGED*>(
               &_S_AIDAMAGED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(S_AIDAMAGED& a, S_AIDAMAGED& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AIDAMAGED* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AIDAMAGED* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AIDAMAGED* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AIDAMAGED>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AIDAMAGED& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AIDAMAGED& from) {
    S_AIDAMAGED::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AIDAMAGED* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AIDAMAGED";
  }
  protected:
  explicit S_AIDAMAGED(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kHpFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float hp = 2;
  void clear_hp();
  float hp() const;
  void set_hp(float value);
  private:
  float _internal_hp() const;
  void _internal_set_hp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AIDAMAGED)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float hp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AIDAMAGED final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AIDAMAGED) */ {
 public:
  inline C_AIDAMAGED() : C_AIDAMAGED(nullptr) {}
  ~C_AIDAMAGED() override;
  explicit PROTOBUF_CONSTEXPR C_AIDAMAGED(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AIDAMAGED(const C_AIDAMAGED& from);
  C_AIDAMAGED(C_AIDAMAGED&& from) noexcept
    : C_AIDAMAGED() {
    *this = ::std::move(from);
  }

  inline C_AIDAMAGED& operator=(const C_AIDAMAGED& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AIDAMAGED& operator=(C_AIDAMAGED&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AIDAMAGED& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AIDAMAGED* internal_default_instance() {
    return reinterpret_cast<const C_AIDAMAGED*>(
               &_C_AIDAMAGED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(C_AIDAMAGED& a, C_AIDAMAGED& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AIDAMAGED* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AIDAMAGED* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AIDAMAGED* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AIDAMAGED>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AIDAMAGED& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AIDAMAGED& from) {
    C_AIDAMAGED::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AIDAMAGED* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AIDAMAGED";
  }
  protected:
  explicit C_AIDAMAGED(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kHpFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float hp = 2;
  void clear_hp();
  float hp() const;
  void set_hp(float value);
  private:
  float _internal_hp() const;
  void _internal_set_hp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AIDAMAGED)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float hp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AIDEAD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AIDEAD) */ {
 public:
  inline S_AIDEAD() : S_AIDEAD(nullptr) {}
  ~S_AIDEAD() override;
  explicit PROTOBUF_CONSTEXPR S_AIDEAD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AIDEAD(const S_AIDEAD& from);
  S_AIDEAD(S_AIDEAD&& from) noexcept
    : S_AIDEAD() {
    *this = ::std::move(from);
  }

  inline S_AIDEAD& operator=(const S_AIDEAD& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AIDEAD& operator=(S_AIDEAD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AIDEAD& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AIDEAD* internal_default_instance() {
    return reinterpret_cast<const S_AIDEAD*>(
               &_S_AIDEAD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(S_AIDEAD& a, S_AIDEAD& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AIDEAD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AIDEAD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AIDEAD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AIDEAD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AIDEAD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AIDEAD& from) {
    S_AIDEAD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AIDEAD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AIDEAD";
  }
  protected:
  explicit S_AIDEAD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kOwnerObjectIdFieldNumber = 3,
    kDeadFieldNumber = 2,
    kExpFieldNumber = 4,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 owner_object_id = 3;
  void clear_owner_object_id();
  uint64_t owner_object_id() const;
  void set_owner_object_id(uint64_t value);
  private:
  uint64_t _internal_owner_object_id() const;
  void _internal_set_owner_object_id(uint64_t value);
  public:

  // bool dead = 2;
  void clear_dead();
  bool dead() const;
  void set_dead(bool value);
  private:
  bool _internal_dead() const;
  void _internal_set_dead(bool value);
  public:

  // float exp = 4;
  void clear_exp();
  float exp() const;
  void set_exp(float value);
  private:
  float _internal_exp() const;
  void _internal_set_exp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AIDEAD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t owner_object_id_;
    bool dead_;
    float exp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AIDEAD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AIDEAD) */ {
 public:
  inline C_AIDEAD() : C_AIDEAD(nullptr) {}
  ~C_AIDEAD() override;
  explicit PROTOBUF_CONSTEXPR C_AIDEAD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AIDEAD(const C_AIDEAD& from);
  C_AIDEAD(C_AIDEAD&& from) noexcept
    : C_AIDEAD() {
    *this = ::std::move(from);
  }

  inline C_AIDEAD& operator=(const C_AIDEAD& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AIDEAD& operator=(C_AIDEAD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AIDEAD& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AIDEAD* internal_default_instance() {
    return reinterpret_cast<const C_AIDEAD*>(
               &_C_AIDEAD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(C_AIDEAD& a, C_AIDEAD& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AIDEAD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AIDEAD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AIDEAD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AIDEAD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AIDEAD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AIDEAD& from) {
    C_AIDEAD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AIDEAD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AIDEAD";
  }
  protected:
  explicit C_AIDEAD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kOwnerObjectIdFieldNumber = 3,
    kDeadFieldNumber = 2,
    kExpFieldNumber = 4,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 owner_object_id = 3;
  void clear_owner_object_id();
  uint64_t owner_object_id() const;
  void set_owner_object_id(uint64_t value);
  private:
  uint64_t _internal_owner_object_id() const;
  void _internal_set_owner_object_id(uint64_t value);
  public:

  // bool dead = 2;
  void clear_dead();
  bool dead() const;
  void set_dead(bool value);
  private:
  bool _internal_dead() const;
  void _internal_set_dead(bool value);
  public:

  // float exp = 4;
  void clear_exp();
  float exp() const;
  void set_exp(float value);
  private:
  float _internal_exp() const;
  void _internal_set_exp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AIDEAD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t owner_object_id_;
    bool dead_;
    float exp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PLAYERDEAD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PLAYERDEAD) */ {
 public:
  inline S_PLAYERDEAD() : S_PLAYERDEAD(nullptr) {}
  ~S_PLAYERDEAD() override;
  explicit PROTOBUF_CONSTEXPR S_PLAYERDEAD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PLAYERDEAD(const S_PLAYERDEAD& from);
  S_PLAYERDEAD(S_PLAYERDEAD&& from) noexcept
    : S_PLAYERDEAD() {
    *this = ::std::move(from);
  }

  inline S_PLAYERDEAD& operator=(const S_PLAYERDEAD& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PLAYERDEAD& operator=(S_PLAYERDEAD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PLAYERDEAD& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PLAYERDEAD* internal_default_instance() {
    return reinterpret_cast<const S_PLAYERDEAD*>(
               &_S_PLAYERDEAD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(S_PLAYERDEAD& a, S_PLAYERDEAD& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PLAYERDEAD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PLAYERDEAD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PLAYERDEAD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PLAYERDEAD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PLAYERDEAD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PLAYERDEAD& from) {
    S_PLAYERDEAD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PLAYERDEAD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PLAYERDEAD";
  }
  protected:
  explicit S_PLAYERDEAD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kDeadFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // bool dead = 2;
  void clear_dead();
  bool dead() const;
  void set_dead(bool value);
  private:
  bool _internal_dead() const;
  void _internal_set_dead(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PLAYERDEAD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    bool dead_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PLAYERDEAD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PLAYERDEAD) */ {
 public:
  inline C_PLAYERDEAD() : C_PLAYERDEAD(nullptr) {}
  ~C_PLAYERDEAD() override;
  explicit PROTOBUF_CONSTEXPR C_PLAYERDEAD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PLAYERDEAD(const C_PLAYERDEAD& from);
  C_PLAYERDEAD(C_PLAYERDEAD&& from) noexcept
    : C_PLAYERDEAD() {
    *this = ::std::move(from);
  }

  inline C_PLAYERDEAD& operator=(const C_PLAYERDEAD& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PLAYERDEAD& operator=(C_PLAYERDEAD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PLAYERDEAD& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PLAYERDEAD* internal_default_instance() {
    return reinterpret_cast<const C_PLAYERDEAD*>(
               &_C_PLAYERDEAD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(C_PLAYERDEAD& a, C_PLAYERDEAD& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PLAYERDEAD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PLAYERDEAD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PLAYERDEAD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PLAYERDEAD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PLAYERDEAD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PLAYERDEAD& from) {
    C_PLAYERDEAD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PLAYERDEAD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PLAYERDEAD";
  }
  protected:
  explicit C_PLAYERDEAD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kDeadFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // bool dead = 2;
  void clear_dead();
  bool dead() const;
  void set_dead(bool value);
  private:
  bool _internal_dead() const;
  void _internal_set_dead(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PLAYERDEAD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    bool dead_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AIPROJSPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AIPROJSPAWN) */ {
 public:
  inline S_AIPROJSPAWN() : S_AIPROJSPAWN(nullptr) {}
  ~S_AIPROJSPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_AIPROJSPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AIPROJSPAWN(const S_AIPROJSPAWN& from);
  S_AIPROJSPAWN(S_AIPROJSPAWN&& from) noexcept
    : S_AIPROJSPAWN() {
    *this = ::std::move(from);
  }

  inline S_AIPROJSPAWN& operator=(const S_AIPROJSPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AIPROJSPAWN& operator=(S_AIPROJSPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AIPROJSPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AIPROJSPAWN* internal_default_instance() {
    return reinterpret_cast<const S_AIPROJSPAWN*>(
               &_S_AIPROJSPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(S_AIPROJSPAWN& a, S_AIPROJSPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AIPROJSPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AIPROJSPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AIPROJSPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AIPROJSPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AIPROJSPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AIPROJSPAWN& from) {
    S_AIPROJSPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AIPROJSPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AIPROJSPAWN";
  }
  protected:
  explicit S_AIPROJSPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kProjIdxFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
    kYawFieldNumber = 6,
    kPitchFieldNumber = 7,
    kRollFieldNumber = 8,
    kSpeedFieldNumber = 9,
    kAttackDmgFieldNumber = 10,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // int64 ProjIdx = 2;
  void clear_projidx();
  int64_t projidx() const;
  void set_projidx(int64_t value);
  private:
  int64_t _internal_projidx() const;
  void _internal_set_projidx(int64_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float yaw = 6;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float pitch = 7;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 8;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // float speed = 9;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // float attackDmg = 10;
  void clear_attackdmg();
  float attackdmg() const;
  void set_attackdmg(float value);
  private:
  float _internal_attackdmg() const;
  void _internal_set_attackdmg(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AIPROJSPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int64_t projidx_;
    float x_;
    float y_;
    float z_;
    float yaw_;
    float pitch_;
    float roll_;
    float speed_;
    float attackdmg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AIPROJSPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AIPROJSPAWN) */ {
 public:
  inline C_AIPROJSPAWN() : C_AIPROJSPAWN(nullptr) {}
  ~C_AIPROJSPAWN() override;
  explicit PROTOBUF_CONSTEXPR C_AIPROJSPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AIPROJSPAWN(const C_AIPROJSPAWN& from);
  C_AIPROJSPAWN(C_AIPROJSPAWN&& from) noexcept
    : C_AIPROJSPAWN() {
    *this = ::std::move(from);
  }

  inline C_AIPROJSPAWN& operator=(const C_AIPROJSPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AIPROJSPAWN& operator=(C_AIPROJSPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AIPROJSPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AIPROJSPAWN* internal_default_instance() {
    return reinterpret_cast<const C_AIPROJSPAWN*>(
               &_C_AIPROJSPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(C_AIPROJSPAWN& a, C_AIPROJSPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AIPROJSPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AIPROJSPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AIPROJSPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AIPROJSPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AIPROJSPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AIPROJSPAWN& from) {
    C_AIPROJSPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AIPROJSPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AIPROJSPAWN";
  }
  protected:
  explicit C_AIPROJSPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kProjIdxFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
    kYawFieldNumber = 6,
    kPitchFieldNumber = 7,
    kRollFieldNumber = 8,
    kSpeedFieldNumber = 9,
    kAttackDmgFieldNumber = 10,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // int64 ProjIdx = 2;
  void clear_projidx();
  int64_t projidx() const;
  void set_projidx(int64_t value);
  private:
  int64_t _internal_projidx() const;
  void _internal_set_projidx(int64_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float yaw = 6;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float pitch = 7;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 8;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // float speed = 9;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // float attackDmg = 10;
  void clear_attackdmg();
  float attackdmg() const;
  void set_attackdmg(float value);
  private:
  float _internal_attackdmg() const;
  void _internal_set_attackdmg(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AIPROJSPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int64_t projidx_;
    float x_;
    float y_;
    float z_;
    float yaw_;
    float pitch_;
    float roll_;
    float speed_;
    float attackdmg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AI_KNOCKS_BACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AI_KNOCKS_BACK) */ {
 public:
  inline S_AI_KNOCKS_BACK() : S_AI_KNOCKS_BACK(nullptr) {}
  ~S_AI_KNOCKS_BACK() override;
  explicit PROTOBUF_CONSTEXPR S_AI_KNOCKS_BACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AI_KNOCKS_BACK(const S_AI_KNOCKS_BACK& from);
  S_AI_KNOCKS_BACK(S_AI_KNOCKS_BACK&& from) noexcept
    : S_AI_KNOCKS_BACK() {
    *this = ::std::move(from);
  }

  inline S_AI_KNOCKS_BACK& operator=(const S_AI_KNOCKS_BACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AI_KNOCKS_BACK& operator=(S_AI_KNOCKS_BACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AI_KNOCKS_BACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AI_KNOCKS_BACK* internal_default_instance() {
    return reinterpret_cast<const S_AI_KNOCKS_BACK*>(
               &_S_AI_KNOCKS_BACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(S_AI_KNOCKS_BACK& a, S_AI_KNOCKS_BACK& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AI_KNOCKS_BACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AI_KNOCKS_BACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AI_KNOCKS_BACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AI_KNOCKS_BACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AI_KNOCKS_BACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_AI_KNOCKS_BACK& from) {
    S_AI_KNOCKS_BACK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AI_KNOCKS_BACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AI_KNOCKS_BACK";
  }
  protected:
  explicit S_AI_KNOCKS_BACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kVxFieldNumber = 3,
    kVyFieldNumber = 4,
    kVzFieldNumber = 5,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 target_id = 2;
  void clear_target_id();
  uint64_t target_id() const;
  void set_target_id(uint64_t value);
  private:
  uint64_t _internal_target_id() const;
  void _internal_set_target_id(uint64_t value);
  public:

  // float vx = 3;
  void clear_vx();
  float vx() const;
  void set_vx(float value);
  private:
  float _internal_vx() const;
  void _internal_set_vx(float value);
  public:

  // float vy = 4;
  void clear_vy();
  float vy() const;
  void set_vy(float value);
  private:
  float _internal_vy() const;
  void _internal_set_vy(float value);
  public:

  // float vz = 5;
  void clear_vz();
  float vz() const;
  void set_vz(float value);
  private:
  float _internal_vz() const;
  void _internal_set_vz(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AI_KNOCKS_BACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t target_id_;
    float vx_;
    float vy_;
    float vz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AI_KNOCKS_BACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AI_KNOCKS_BACK) */ {
 public:
  inline C_AI_KNOCKS_BACK() : C_AI_KNOCKS_BACK(nullptr) {}
  ~C_AI_KNOCKS_BACK() override;
  explicit PROTOBUF_CONSTEXPR C_AI_KNOCKS_BACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AI_KNOCKS_BACK(const C_AI_KNOCKS_BACK& from);
  C_AI_KNOCKS_BACK(C_AI_KNOCKS_BACK&& from) noexcept
    : C_AI_KNOCKS_BACK() {
    *this = ::std::move(from);
  }

  inline C_AI_KNOCKS_BACK& operator=(const C_AI_KNOCKS_BACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AI_KNOCKS_BACK& operator=(C_AI_KNOCKS_BACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AI_KNOCKS_BACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AI_KNOCKS_BACK* internal_default_instance() {
    return reinterpret_cast<const C_AI_KNOCKS_BACK*>(
               &_C_AI_KNOCKS_BACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(C_AI_KNOCKS_BACK& a, C_AI_KNOCKS_BACK& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AI_KNOCKS_BACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AI_KNOCKS_BACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AI_KNOCKS_BACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AI_KNOCKS_BACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AI_KNOCKS_BACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AI_KNOCKS_BACK& from) {
    C_AI_KNOCKS_BACK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AI_KNOCKS_BACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AI_KNOCKS_BACK";
  }
  protected:
  explicit C_AI_KNOCKS_BACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kVxFieldNumber = 3,
    kVyFieldNumber = 4,
    kVzFieldNumber = 5,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 target_id = 2;
  void clear_target_id();
  uint64_t target_id() const;
  void set_target_id(uint64_t value);
  private:
  uint64_t _internal_target_id() const;
  void _internal_set_target_id(uint64_t value);
  public:

  // float vx = 3;
  void clear_vx();
  float vx() const;
  void set_vx(float value);
  private:
  float _internal_vx() const;
  void _internal_set_vx(float value);
  public:

  // float vy = 4;
  void clear_vy();
  float vy() const;
  void set_vy(float value);
  private:
  float _internal_vy() const;
  void _internal_set_vy(float value);
  public:

  // float vz = 5;
  void clear_vz();
  float vz() const;
  void set_vz(float value);
  private:
  float _internal_vz() const;
  void _internal_set_vz(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AI_KNOCKS_BACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t target_id_;
    float vx_;
    float vy_;
    float vz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PLAYERSKILL_BOMB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PLAYERSKILL_BOMB) */ {
 public:
  inline S_PLAYERSKILL_BOMB() : S_PLAYERSKILL_BOMB(nullptr) {}
  ~S_PLAYERSKILL_BOMB() override;
  explicit PROTOBUF_CONSTEXPR S_PLAYERSKILL_BOMB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PLAYERSKILL_BOMB(const S_PLAYERSKILL_BOMB& from);
  S_PLAYERSKILL_BOMB(S_PLAYERSKILL_BOMB&& from) noexcept
    : S_PLAYERSKILL_BOMB() {
    *this = ::std::move(from);
  }

  inline S_PLAYERSKILL_BOMB& operator=(const S_PLAYERSKILL_BOMB& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PLAYERSKILL_BOMB& operator=(S_PLAYERSKILL_BOMB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PLAYERSKILL_BOMB& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PLAYERSKILL_BOMB* internal_default_instance() {
    return reinterpret_cast<const S_PLAYERSKILL_BOMB*>(
               &_S_PLAYERSKILL_BOMB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(S_PLAYERSKILL_BOMB& a, S_PLAYERSKILL_BOMB& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PLAYERSKILL_BOMB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PLAYERSKILL_BOMB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PLAYERSKILL_BOMB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PLAYERSKILL_BOMB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PLAYERSKILL_BOMB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PLAYERSKILL_BOMB& from) {
    S_PLAYERSKILL_BOMB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PLAYERSKILL_BOMB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PLAYERSKILL_BOMB";
  }
  protected:
  explicit S_PLAYERSKILL_BOMB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAbilityArrayIdxFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
    kDmgFieldNumber = 6,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 abilityArrayIdx = 2;
  void clear_abilityarrayidx();
  uint64_t abilityarrayidx() const;
  void set_abilityarrayidx(uint64_t value);
  private:
  uint64_t _internal_abilityarrayidx() const;
  void _internal_set_abilityarrayidx(uint64_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float dmg = 6;
  void clear_dmg();
  float dmg() const;
  void set_dmg(float value);
  private:
  float _internal_dmg() const;
  void _internal_set_dmg(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PLAYERSKILL_BOMB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t abilityarrayidx_;
    float x_;
    float y_;
    float z_;
    float dmg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PLAYERSKILL_BOMB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PLAYERSKILL_BOMB) */ {
 public:
  inline C_PLAYERSKILL_BOMB() : C_PLAYERSKILL_BOMB(nullptr) {}
  ~C_PLAYERSKILL_BOMB() override;
  explicit PROTOBUF_CONSTEXPR C_PLAYERSKILL_BOMB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PLAYERSKILL_BOMB(const C_PLAYERSKILL_BOMB& from);
  C_PLAYERSKILL_BOMB(C_PLAYERSKILL_BOMB&& from) noexcept
    : C_PLAYERSKILL_BOMB() {
    *this = ::std::move(from);
  }

  inline C_PLAYERSKILL_BOMB& operator=(const C_PLAYERSKILL_BOMB& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PLAYERSKILL_BOMB& operator=(C_PLAYERSKILL_BOMB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PLAYERSKILL_BOMB& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PLAYERSKILL_BOMB* internal_default_instance() {
    return reinterpret_cast<const C_PLAYERSKILL_BOMB*>(
               &_C_PLAYERSKILL_BOMB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(C_PLAYERSKILL_BOMB& a, C_PLAYERSKILL_BOMB& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PLAYERSKILL_BOMB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PLAYERSKILL_BOMB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PLAYERSKILL_BOMB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PLAYERSKILL_BOMB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PLAYERSKILL_BOMB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PLAYERSKILL_BOMB& from) {
    C_PLAYERSKILL_BOMB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PLAYERSKILL_BOMB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PLAYERSKILL_BOMB";
  }
  protected:
  explicit C_PLAYERSKILL_BOMB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAbilityArrayIdxFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
    kDmgFieldNumber = 6,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 abilityArrayIdx = 2;
  void clear_abilityarrayidx();
  uint64_t abilityarrayidx() const;
  void set_abilityarrayidx(uint64_t value);
  private:
  uint64_t _internal_abilityarrayidx() const;
  void _internal_set_abilityarrayidx(uint64_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float dmg = 6;
  void clear_dmg();
  float dmg() const;
  void set_dmg(float value);
  private:
  float _internal_dmg() const;
  void _internal_set_dmg(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PLAYERSKILL_BOMB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t abilityarrayidx_;
    float x_;
    float y_;
    float z_;
    float dmg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PLAYERSKILL_GRANADE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PLAYERSKILL_GRANADE) */ {
 public:
  inline S_PLAYERSKILL_GRANADE() : S_PLAYERSKILL_GRANADE(nullptr) {}
  ~S_PLAYERSKILL_GRANADE() override;
  explicit PROTOBUF_CONSTEXPR S_PLAYERSKILL_GRANADE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PLAYERSKILL_GRANADE(const S_PLAYERSKILL_GRANADE& from);
  S_PLAYERSKILL_GRANADE(S_PLAYERSKILL_GRANADE&& from) noexcept
    : S_PLAYERSKILL_GRANADE() {
    *this = ::std::move(from);
  }

  inline S_PLAYERSKILL_GRANADE& operator=(const S_PLAYERSKILL_GRANADE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PLAYERSKILL_GRANADE& operator=(S_PLAYERSKILL_GRANADE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PLAYERSKILL_GRANADE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PLAYERSKILL_GRANADE* internal_default_instance() {
    return reinterpret_cast<const S_PLAYERSKILL_GRANADE*>(
               &_S_PLAYERSKILL_GRANADE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(S_PLAYERSKILL_GRANADE& a, S_PLAYERSKILL_GRANADE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PLAYERSKILL_GRANADE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PLAYERSKILL_GRANADE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PLAYERSKILL_GRANADE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PLAYERSKILL_GRANADE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PLAYERSKILL_GRANADE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PLAYERSKILL_GRANADE& from) {
    S_PLAYERSKILL_GRANADE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PLAYERSKILL_GRANADE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PLAYERSKILL_GRANADE";
  }
  protected:
  explicit S_PLAYERSKILL_GRANADE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAbilityArrayIdxFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
    kRxFieldNumber = 6,
    kRyFieldNumber = 7,
    kRzFieldNumber = 8,
    kDmgFieldNumber = 9,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 abilityArrayIdx = 2;
  void clear_abilityarrayidx();
  uint64_t abilityarrayidx() const;
  void set_abilityarrayidx(uint64_t value);
  private:
  uint64_t _internal_abilityarrayidx() const;
  void _internal_set_abilityarrayidx(uint64_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float rx = 6;
  void clear_rx();
  float rx() const;
  void set_rx(float value);
  private:
  float _internal_rx() const;
  void _internal_set_rx(float value);
  public:

  // float ry = 7;
  void clear_ry();
  float ry() const;
  void set_ry(float value);
  private:
  float _internal_ry() const;
  void _internal_set_ry(float value);
  public:

  // float rz = 8;
  void clear_rz();
  float rz() const;
  void set_rz(float value);
  private:
  float _internal_rz() const;
  void _internal_set_rz(float value);
  public:

  // float dmg = 9;
  void clear_dmg();
  float dmg() const;
  void set_dmg(float value);
  private:
  float _internal_dmg() const;
  void _internal_set_dmg(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PLAYERSKILL_GRANADE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t abilityarrayidx_;
    float x_;
    float y_;
    float z_;
    float rx_;
    float ry_;
    float rz_;
    float dmg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PLAYERSKILL_GRANADE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PLAYERSKILL_GRANADE) */ {
 public:
  inline C_PLAYERSKILL_GRANADE() : C_PLAYERSKILL_GRANADE(nullptr) {}
  ~C_PLAYERSKILL_GRANADE() override;
  explicit PROTOBUF_CONSTEXPR C_PLAYERSKILL_GRANADE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PLAYERSKILL_GRANADE(const C_PLAYERSKILL_GRANADE& from);
  C_PLAYERSKILL_GRANADE(C_PLAYERSKILL_GRANADE&& from) noexcept
    : C_PLAYERSKILL_GRANADE() {
    *this = ::std::move(from);
  }

  inline C_PLAYERSKILL_GRANADE& operator=(const C_PLAYERSKILL_GRANADE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PLAYERSKILL_GRANADE& operator=(C_PLAYERSKILL_GRANADE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PLAYERSKILL_GRANADE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PLAYERSKILL_GRANADE* internal_default_instance() {
    return reinterpret_cast<const C_PLAYERSKILL_GRANADE*>(
               &_C_PLAYERSKILL_GRANADE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(C_PLAYERSKILL_GRANADE& a, C_PLAYERSKILL_GRANADE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PLAYERSKILL_GRANADE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PLAYERSKILL_GRANADE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PLAYERSKILL_GRANADE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PLAYERSKILL_GRANADE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PLAYERSKILL_GRANADE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PLAYERSKILL_GRANADE& from) {
    C_PLAYERSKILL_GRANADE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PLAYERSKILL_GRANADE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PLAYERSKILL_GRANADE";
  }
  protected:
  explicit C_PLAYERSKILL_GRANADE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAbilityArrayIdxFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
    kRxFieldNumber = 6,
    kRyFieldNumber = 7,
    kRzFieldNumber = 8,
    kDmgFieldNumber = 9,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 abilityArrayIdx = 2;
  void clear_abilityarrayidx();
  uint64_t abilityarrayidx() const;
  void set_abilityarrayidx(uint64_t value);
  private:
  uint64_t _internal_abilityarrayidx() const;
  void _internal_set_abilityarrayidx(uint64_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float rx = 6;
  void clear_rx();
  float rx() const;
  void set_rx(float value);
  private:
  float _internal_rx() const;
  void _internal_set_rx(float value);
  public:

  // float ry = 7;
  void clear_ry();
  float ry() const;
  void set_ry(float value);
  private:
  float _internal_ry() const;
  void _internal_set_ry(float value);
  public:

  // float rz = 8;
  void clear_rz();
  float rz() const;
  void set_rz(float value);
  private:
  float _internal_rz() const;
  void _internal_set_rz(float value);
  public:

  // float dmg = 9;
  void clear_dmg();
  float dmg() const;
  void set_dmg(float value);
  private:
  float _internal_dmg() const;
  void _internal_set_dmg(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PLAYERSKILL_GRANADE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t abilityarrayidx_;
    float x_;
    float y_;
    float z_;
    float rx_;
    float ry_;
    float rz_;
    float dmg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PLAYERSKILL_CHEMICAL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PLAYERSKILL_CHEMICAL) */ {
 public:
  inline S_PLAYERSKILL_CHEMICAL() : S_PLAYERSKILL_CHEMICAL(nullptr) {}
  ~S_PLAYERSKILL_CHEMICAL() override;
  explicit PROTOBUF_CONSTEXPR S_PLAYERSKILL_CHEMICAL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PLAYERSKILL_CHEMICAL(const S_PLAYERSKILL_CHEMICAL& from);
  S_PLAYERSKILL_CHEMICAL(S_PLAYERSKILL_CHEMICAL&& from) noexcept
    : S_PLAYERSKILL_CHEMICAL() {
    *this = ::std::move(from);
  }

  inline S_PLAYERSKILL_CHEMICAL& operator=(const S_PLAYERSKILL_CHEMICAL& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PLAYERSKILL_CHEMICAL& operator=(S_PLAYERSKILL_CHEMICAL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PLAYERSKILL_CHEMICAL& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PLAYERSKILL_CHEMICAL* internal_default_instance() {
    return reinterpret_cast<const S_PLAYERSKILL_CHEMICAL*>(
               &_S_PLAYERSKILL_CHEMICAL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(S_PLAYERSKILL_CHEMICAL& a, S_PLAYERSKILL_CHEMICAL& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PLAYERSKILL_CHEMICAL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PLAYERSKILL_CHEMICAL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PLAYERSKILL_CHEMICAL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PLAYERSKILL_CHEMICAL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PLAYERSKILL_CHEMICAL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PLAYERSKILL_CHEMICAL& from) {
    S_PLAYERSKILL_CHEMICAL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PLAYERSKILL_CHEMICAL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PLAYERSKILL_CHEMICAL";
  }
  protected:
  explicit S_PLAYERSKILL_CHEMICAL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAbilityArrayIdxFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
    kDmgFieldNumber = 6,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 abilityArrayIdx = 2;
  void clear_abilityarrayidx();
  uint64_t abilityarrayidx() const;
  void set_abilityarrayidx(uint64_t value);
  private:
  uint64_t _internal_abilityarrayidx() const;
  void _internal_set_abilityarrayidx(uint64_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float dmg = 6;
  void clear_dmg();
  float dmg() const;
  void set_dmg(float value);
  private:
  float _internal_dmg() const;
  void _internal_set_dmg(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PLAYERSKILL_CHEMICAL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t abilityarrayidx_;
    float x_;
    float y_;
    float z_;
    float dmg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PLAYERSKILL_CHEMICAL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PLAYERSKILL_CHEMICAL) */ {
 public:
  inline C_PLAYERSKILL_CHEMICAL() : C_PLAYERSKILL_CHEMICAL(nullptr) {}
  ~C_PLAYERSKILL_CHEMICAL() override;
  explicit PROTOBUF_CONSTEXPR C_PLAYERSKILL_CHEMICAL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PLAYERSKILL_CHEMICAL(const C_PLAYERSKILL_CHEMICAL& from);
  C_PLAYERSKILL_CHEMICAL(C_PLAYERSKILL_CHEMICAL&& from) noexcept
    : C_PLAYERSKILL_CHEMICAL() {
    *this = ::std::move(from);
  }

  inline C_PLAYERSKILL_CHEMICAL& operator=(const C_PLAYERSKILL_CHEMICAL& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PLAYERSKILL_CHEMICAL& operator=(C_PLAYERSKILL_CHEMICAL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PLAYERSKILL_CHEMICAL& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PLAYERSKILL_CHEMICAL* internal_default_instance() {
    return reinterpret_cast<const C_PLAYERSKILL_CHEMICAL*>(
               &_C_PLAYERSKILL_CHEMICAL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(C_PLAYERSKILL_CHEMICAL& a, C_PLAYERSKILL_CHEMICAL& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PLAYERSKILL_CHEMICAL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PLAYERSKILL_CHEMICAL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PLAYERSKILL_CHEMICAL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PLAYERSKILL_CHEMICAL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PLAYERSKILL_CHEMICAL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PLAYERSKILL_CHEMICAL& from) {
    C_PLAYERSKILL_CHEMICAL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PLAYERSKILL_CHEMICAL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PLAYERSKILL_CHEMICAL";
  }
  protected:
  explicit C_PLAYERSKILL_CHEMICAL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAbilityArrayIdxFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
    kDmgFieldNumber = 6,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 abilityArrayIdx = 2;
  void clear_abilityarrayidx();
  uint64_t abilityarrayidx() const;
  void set_abilityarrayidx(uint64_t value);
  private:
  uint64_t _internal_abilityarrayidx() const;
  void _internal_set_abilityarrayidx(uint64_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float dmg = 6;
  void clear_dmg();
  float dmg() const;
  void set_dmg(float value);
  private:
  float _internal_dmg() const;
  void _internal_set_dmg(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PLAYERSKILL_CHEMICAL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t abilityarrayidx_;
    float x_;
    float y_;
    float z_;
    float dmg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PLAYERSKILL_GUARD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PLAYERSKILL_GUARD) */ {
 public:
  inline S_PLAYERSKILL_GUARD() : S_PLAYERSKILL_GUARD(nullptr) {}
  ~S_PLAYERSKILL_GUARD() override;
  explicit PROTOBUF_CONSTEXPR S_PLAYERSKILL_GUARD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PLAYERSKILL_GUARD(const S_PLAYERSKILL_GUARD& from);
  S_PLAYERSKILL_GUARD(S_PLAYERSKILL_GUARD&& from) noexcept
    : S_PLAYERSKILL_GUARD() {
    *this = ::std::move(from);
  }

  inline S_PLAYERSKILL_GUARD& operator=(const S_PLAYERSKILL_GUARD& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PLAYERSKILL_GUARD& operator=(S_PLAYERSKILL_GUARD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PLAYERSKILL_GUARD& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PLAYERSKILL_GUARD* internal_default_instance() {
    return reinterpret_cast<const S_PLAYERSKILL_GUARD*>(
               &_S_PLAYERSKILL_GUARD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(S_PLAYERSKILL_GUARD& a, S_PLAYERSKILL_GUARD& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PLAYERSKILL_GUARD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PLAYERSKILL_GUARD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PLAYERSKILL_GUARD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PLAYERSKILL_GUARD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PLAYERSKILL_GUARD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PLAYERSKILL_GUARD& from) {
    S_PLAYERSKILL_GUARD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PLAYERSKILL_GUARD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PLAYERSKILL_GUARD";
  }
  protected:
  explicit S_PLAYERSKILL_GUARD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kGuardPointFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 guardPoint = 2;
  void clear_guardpoint();
  uint64_t guardpoint() const;
  void set_guardpoint(uint64_t value);
  private:
  uint64_t _internal_guardpoint() const;
  void _internal_set_guardpoint(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PLAYERSKILL_GUARD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t guardpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PLAYERSKILL_GUARD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PLAYERSKILL_GUARD) */ {
 public:
  inline C_PLAYERSKILL_GUARD() : C_PLAYERSKILL_GUARD(nullptr) {}
  ~C_PLAYERSKILL_GUARD() override;
  explicit PROTOBUF_CONSTEXPR C_PLAYERSKILL_GUARD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PLAYERSKILL_GUARD(const C_PLAYERSKILL_GUARD& from);
  C_PLAYERSKILL_GUARD(C_PLAYERSKILL_GUARD&& from) noexcept
    : C_PLAYERSKILL_GUARD() {
    *this = ::std::move(from);
  }

  inline C_PLAYERSKILL_GUARD& operator=(const C_PLAYERSKILL_GUARD& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PLAYERSKILL_GUARD& operator=(C_PLAYERSKILL_GUARD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PLAYERSKILL_GUARD& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PLAYERSKILL_GUARD* internal_default_instance() {
    return reinterpret_cast<const C_PLAYERSKILL_GUARD*>(
               &_C_PLAYERSKILL_GUARD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(C_PLAYERSKILL_GUARD& a, C_PLAYERSKILL_GUARD& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PLAYERSKILL_GUARD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PLAYERSKILL_GUARD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PLAYERSKILL_GUARD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PLAYERSKILL_GUARD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PLAYERSKILL_GUARD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PLAYERSKILL_GUARD& from) {
    C_PLAYERSKILL_GUARD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PLAYERSKILL_GUARD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PLAYERSKILL_GUARD";
  }
  protected:
  explicit C_PLAYERSKILL_GUARD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kGuardPointFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 guardPoint = 2;
  void clear_guardpoint();
  uint64_t guardpoint() const;
  void set_guardpoint(uint64_t value);
  private:
  uint64_t _internal_guardpoint() const;
  void _internal_set_guardpoint(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PLAYERSKILL_GUARD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t guardpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PLAYERSKILL_HEAL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PLAYERSKILL_HEAL) */ {
 public:
  inline S_PLAYERSKILL_HEAL() : S_PLAYERSKILL_HEAL(nullptr) {}
  ~S_PLAYERSKILL_HEAL() override;
  explicit PROTOBUF_CONSTEXPR S_PLAYERSKILL_HEAL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PLAYERSKILL_HEAL(const S_PLAYERSKILL_HEAL& from);
  S_PLAYERSKILL_HEAL(S_PLAYERSKILL_HEAL&& from) noexcept
    : S_PLAYERSKILL_HEAL() {
    *this = ::std::move(from);
  }

  inline S_PLAYERSKILL_HEAL& operator=(const S_PLAYERSKILL_HEAL& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PLAYERSKILL_HEAL& operator=(S_PLAYERSKILL_HEAL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PLAYERSKILL_HEAL& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PLAYERSKILL_HEAL* internal_default_instance() {
    return reinterpret_cast<const S_PLAYERSKILL_HEAL*>(
               &_S_PLAYERSKILL_HEAL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(S_PLAYERSKILL_HEAL& a, S_PLAYERSKILL_HEAL& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PLAYERSKILL_HEAL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PLAYERSKILL_HEAL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PLAYERSKILL_HEAL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PLAYERSKILL_HEAL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PLAYERSKILL_HEAL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PLAYERSKILL_HEAL& from) {
    S_PLAYERSKILL_HEAL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PLAYERSKILL_HEAL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PLAYERSKILL_HEAL";
  }
  protected:
  explicit S_PLAYERSKILL_HEAL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAbilityArrayIdxFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 abilityArrayIdx = 2;
  void clear_abilityarrayidx();
  uint64_t abilityarrayidx() const;
  void set_abilityarrayidx(uint64_t value);
  private:
  uint64_t _internal_abilityarrayidx() const;
  void _internal_set_abilityarrayidx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PLAYERSKILL_HEAL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t abilityarrayidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PLAYERSKILL_HEAL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PLAYERSKILL_HEAL) */ {
 public:
  inline C_PLAYERSKILL_HEAL() : C_PLAYERSKILL_HEAL(nullptr) {}
  ~C_PLAYERSKILL_HEAL() override;
  explicit PROTOBUF_CONSTEXPR C_PLAYERSKILL_HEAL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PLAYERSKILL_HEAL(const C_PLAYERSKILL_HEAL& from);
  C_PLAYERSKILL_HEAL(C_PLAYERSKILL_HEAL&& from) noexcept
    : C_PLAYERSKILL_HEAL() {
    *this = ::std::move(from);
  }

  inline C_PLAYERSKILL_HEAL& operator=(const C_PLAYERSKILL_HEAL& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PLAYERSKILL_HEAL& operator=(C_PLAYERSKILL_HEAL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PLAYERSKILL_HEAL& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PLAYERSKILL_HEAL* internal_default_instance() {
    return reinterpret_cast<const C_PLAYERSKILL_HEAL*>(
               &_C_PLAYERSKILL_HEAL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(C_PLAYERSKILL_HEAL& a, C_PLAYERSKILL_HEAL& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PLAYERSKILL_HEAL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PLAYERSKILL_HEAL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PLAYERSKILL_HEAL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PLAYERSKILL_HEAL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PLAYERSKILL_HEAL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PLAYERSKILL_HEAL& from) {
    C_PLAYERSKILL_HEAL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PLAYERSKILL_HEAL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PLAYERSKILL_HEAL";
  }
  protected:
  explicit C_PLAYERSKILL_HEAL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAbilityArrayIdxFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 abilityArrayIdx = 2;
  void clear_abilityarrayidx();
  uint64_t abilityarrayidx() const;
  void set_abilityarrayidx(uint64_t value);
  private:
  uint64_t _internal_abilityarrayidx() const;
  void _internal_set_abilityarrayidx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PLAYERSKILL_HEAL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t abilityarrayidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PLAYERHEAL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PLAYERHEAL) */ {
 public:
  inline S_PLAYERHEAL() : S_PLAYERHEAL(nullptr) {}
  ~S_PLAYERHEAL() override;
  explicit PROTOBUF_CONSTEXPR S_PLAYERHEAL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PLAYERHEAL(const S_PLAYERHEAL& from);
  S_PLAYERHEAL(S_PLAYERHEAL&& from) noexcept
    : S_PLAYERHEAL() {
    *this = ::std::move(from);
  }

  inline S_PLAYERHEAL& operator=(const S_PLAYERHEAL& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PLAYERHEAL& operator=(S_PLAYERHEAL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PLAYERHEAL& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PLAYERHEAL* internal_default_instance() {
    return reinterpret_cast<const S_PLAYERHEAL*>(
               &_S_PLAYERHEAL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(S_PLAYERHEAL& a, S_PLAYERHEAL& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PLAYERHEAL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PLAYERHEAL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PLAYERHEAL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PLAYERHEAL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PLAYERHEAL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PLAYERHEAL& from) {
    S_PLAYERHEAL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PLAYERHEAL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PLAYERHEAL";
  }
  protected:
  explicit S_PLAYERHEAL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kUpdeatedHPFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 updeatedHP = 2;
  void clear_updeatedhp();
  uint64_t updeatedhp() const;
  void set_updeatedhp(uint64_t value);
  private:
  uint64_t _internal_updeatedhp() const;
  void _internal_set_updeatedhp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PLAYERHEAL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t updeatedhp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PLAYERHEAL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PLAYERHEAL) */ {
 public:
  inline C_PLAYERHEAL() : C_PLAYERHEAL(nullptr) {}
  ~C_PLAYERHEAL() override;
  explicit PROTOBUF_CONSTEXPR C_PLAYERHEAL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PLAYERHEAL(const C_PLAYERHEAL& from);
  C_PLAYERHEAL(C_PLAYERHEAL&& from) noexcept
    : C_PLAYERHEAL() {
    *this = ::std::move(from);
  }

  inline C_PLAYERHEAL& operator=(const C_PLAYERHEAL& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PLAYERHEAL& operator=(C_PLAYERHEAL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PLAYERHEAL& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PLAYERHEAL* internal_default_instance() {
    return reinterpret_cast<const C_PLAYERHEAL*>(
               &_C_PLAYERHEAL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(C_PLAYERHEAL& a, C_PLAYERHEAL& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PLAYERHEAL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PLAYERHEAL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PLAYERHEAL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PLAYERHEAL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PLAYERHEAL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PLAYERHEAL& from) {
    C_PLAYERHEAL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PLAYERHEAL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PLAYERHEAL";
  }
  protected:
  explicit C_PLAYERHEAL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kUpdeatedHPFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 updeatedHP = 2;
  void clear_updeatedhp();
  uint64_t updeatedhp() const;
  void set_updeatedhp(uint64_t value);
  private:
  uint64_t _internal_updeatedhp() const;
  void _internal_set_updeatedhp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_PLAYERHEAL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t updeatedhp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MAKEDRONE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MAKEDRONE) */ {
 public:
  inline S_MAKEDRONE() : S_MAKEDRONE(nullptr) {}
  ~S_MAKEDRONE() override;
  explicit PROTOBUF_CONSTEXPR S_MAKEDRONE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MAKEDRONE(const S_MAKEDRONE& from);
  S_MAKEDRONE(S_MAKEDRONE&& from) noexcept
    : S_MAKEDRONE() {
    *this = ::std::move(from);
  }

  inline S_MAKEDRONE& operator=(const S_MAKEDRONE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MAKEDRONE& operator=(S_MAKEDRONE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MAKEDRONE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MAKEDRONE* internal_default_instance() {
    return reinterpret_cast<const S_MAKEDRONE*>(
               &_S_MAKEDRONE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(S_MAKEDRONE& a, S_MAKEDRONE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MAKEDRONE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MAKEDRONE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MAKEDRONE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MAKEDRONE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MAKEDRONE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MAKEDRONE& from) {
    S_MAKEDRONE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MAKEDRONE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MAKEDRONE";
  }
  protected:
  explicit S_MAKEDRONE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAbilityArrayIdxFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 abilityArrayIdx = 2;
  void clear_abilityarrayidx();
  uint64_t abilityarrayidx() const;
  void set_abilityarrayidx(uint64_t value);
  private:
  uint64_t _internal_abilityarrayidx() const;
  void _internal_set_abilityarrayidx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_MAKEDRONE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t abilityarrayidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MAKEDRONE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MAKEDRONE) */ {
 public:
  inline C_MAKEDRONE() : C_MAKEDRONE(nullptr) {}
  ~C_MAKEDRONE() override;
  explicit PROTOBUF_CONSTEXPR C_MAKEDRONE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MAKEDRONE(const C_MAKEDRONE& from);
  C_MAKEDRONE(C_MAKEDRONE&& from) noexcept
    : C_MAKEDRONE() {
    *this = ::std::move(from);
  }

  inline C_MAKEDRONE& operator=(const C_MAKEDRONE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MAKEDRONE& operator=(C_MAKEDRONE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MAKEDRONE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MAKEDRONE* internal_default_instance() {
    return reinterpret_cast<const C_MAKEDRONE*>(
               &_C_MAKEDRONE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(C_MAKEDRONE& a, C_MAKEDRONE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MAKEDRONE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MAKEDRONE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MAKEDRONE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MAKEDRONE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MAKEDRONE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MAKEDRONE& from) {
    C_MAKEDRONE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MAKEDRONE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MAKEDRONE";
  }
  protected:
  explicit C_MAKEDRONE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAbilityArrayIdxFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // uint64 abilityArrayIdx = 2;
  void clear_abilityarrayidx();
  uint64_t abilityarrayidx() const;
  void set_abilityarrayidx(uint64_t value);
  private:
  uint64_t _internal_abilityarrayidx() const;
  void _internal_set_abilityarrayidx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_MAKEDRONE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    uint64_t abilityarrayidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MOVEDRONE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MOVEDRONE) */ {
 public:
  inline S_MOVEDRONE() : S_MOVEDRONE(nullptr) {}
  ~S_MOVEDRONE() override;
  explicit PROTOBUF_CONSTEXPR S_MOVEDRONE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MOVEDRONE(const S_MOVEDRONE& from);
  S_MOVEDRONE(S_MOVEDRONE&& from) noexcept
    : S_MOVEDRONE() {
    *this = ::std::move(from);
  }

  inline S_MOVEDRONE& operator=(const S_MOVEDRONE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MOVEDRONE& operator=(S_MOVEDRONE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MOVEDRONE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MOVEDRONE* internal_default_instance() {
    return reinterpret_cast<const S_MOVEDRONE*>(
               &_S_MOVEDRONE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(S_MOVEDRONE& a, S_MOVEDRONE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MOVEDRONE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MOVEDRONE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MOVEDRONE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MOVEDRONE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MOVEDRONE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MOVEDRONE& from) {
    S_MOVEDRONE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MOVEDRONE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MOVEDRONE";
  }
  protected:
  explicit S_MOVEDRONE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 4;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_MOVEDRONE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MOVEDRONE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MOVEDRONE) */ {
 public:
  inline C_MOVEDRONE() : C_MOVEDRONE(nullptr) {}
  ~C_MOVEDRONE() override;
  explicit PROTOBUF_CONSTEXPR C_MOVEDRONE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MOVEDRONE(const C_MOVEDRONE& from);
  C_MOVEDRONE(C_MOVEDRONE&& from) noexcept
    : C_MOVEDRONE() {
    *this = ::std::move(from);
  }

  inline C_MOVEDRONE& operator=(const C_MOVEDRONE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MOVEDRONE& operator=(C_MOVEDRONE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MOVEDRONE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MOVEDRONE* internal_default_instance() {
    return reinterpret_cast<const C_MOVEDRONE*>(
               &_C_MOVEDRONE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(C_MOVEDRONE& a, C_MOVEDRONE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MOVEDRONE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MOVEDRONE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MOVEDRONE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MOVEDRONE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MOVEDRONE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MOVEDRONE& from) {
    C_MOVEDRONE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MOVEDRONE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MOVEDRONE";
  }
  protected:
  explicit C_MOVEDRONE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 4;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_MOVEDRONE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SEARCHDRONE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SEARCHDRONE) */ {
 public:
  inline S_SEARCHDRONE() : S_SEARCHDRONE(nullptr) {}
  ~S_SEARCHDRONE() override;
  explicit PROTOBUF_CONSTEXPR S_SEARCHDRONE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SEARCHDRONE(const S_SEARCHDRONE& from);
  S_SEARCHDRONE(S_SEARCHDRONE&& from) noexcept
    : S_SEARCHDRONE() {
    *this = ::std::move(from);
  }

  inline S_SEARCHDRONE& operator=(const S_SEARCHDRONE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SEARCHDRONE& operator=(S_SEARCHDRONE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SEARCHDRONE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SEARCHDRONE* internal_default_instance() {
    return reinterpret_cast<const S_SEARCHDRONE*>(
               &_S_SEARCHDRONE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(S_SEARCHDRONE& a, S_SEARCHDRONE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SEARCHDRONE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SEARCHDRONE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SEARCHDRONE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SEARCHDRONE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SEARCHDRONE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SEARCHDRONE& from) {
    S_SEARCHDRONE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SEARCHDRONE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SEARCHDRONE";
  }
  protected:
  explicit S_SEARCHDRONE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
    kYawFieldNumber = 5,
    kPitchFieldNumber = 6,
    kRollFieldNumber = 7,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 4;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float yaw = 5;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float pitch = 6;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 7;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SEARCHDRONE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float x_;
    float y_;
    float z_;
    float yaw_;
    float pitch_;
    float roll_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SEARCHDRONE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SEARCHDRONE) */ {
 public:
  inline C_SEARCHDRONE() : C_SEARCHDRONE(nullptr) {}
  ~C_SEARCHDRONE() override;
  explicit PROTOBUF_CONSTEXPR C_SEARCHDRONE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SEARCHDRONE(const C_SEARCHDRONE& from);
  C_SEARCHDRONE(C_SEARCHDRONE&& from) noexcept
    : C_SEARCHDRONE() {
    *this = ::std::move(from);
  }

  inline C_SEARCHDRONE& operator=(const C_SEARCHDRONE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SEARCHDRONE& operator=(C_SEARCHDRONE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SEARCHDRONE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SEARCHDRONE* internal_default_instance() {
    return reinterpret_cast<const C_SEARCHDRONE*>(
               &_C_SEARCHDRONE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(C_SEARCHDRONE& a, C_SEARCHDRONE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SEARCHDRONE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SEARCHDRONE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SEARCHDRONE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SEARCHDRONE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SEARCHDRONE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_SEARCHDRONE& from) {
    C_SEARCHDRONE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SEARCHDRONE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SEARCHDRONE";
  }
  protected:
  explicit C_SEARCHDRONE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
    kYawFieldNumber = 5,
    kPitchFieldNumber = 6,
    kRollFieldNumber = 7,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 4;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float yaw = 5;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float pitch = 6;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 7;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SEARCHDRONE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float x_;
    float y_;
    float z_;
    float yaw_;
    float pitch_;
    float roll_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_RETURNDRONE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_RETURNDRONE) */ {
 public:
  inline S_RETURNDRONE() : S_RETURNDRONE(nullptr) {}
  ~S_RETURNDRONE() override;
  explicit PROTOBUF_CONSTEXPR S_RETURNDRONE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_RETURNDRONE(const S_RETURNDRONE& from);
  S_RETURNDRONE(S_RETURNDRONE&& from) noexcept
    : S_RETURNDRONE() {
    *this = ::std::move(from);
  }

  inline S_RETURNDRONE& operator=(const S_RETURNDRONE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_RETURNDRONE& operator=(S_RETURNDRONE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_RETURNDRONE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_RETURNDRONE* internal_default_instance() {
    return reinterpret_cast<const S_RETURNDRONE*>(
               &_S_RETURNDRONE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(S_RETURNDRONE& a, S_RETURNDRONE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_RETURNDRONE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_RETURNDRONE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_RETURNDRONE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_RETURNDRONE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_RETURNDRONE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_RETURNDRONE& from) {
    S_RETURNDRONE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_RETURNDRONE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_RETURNDRONE";
  }
  protected:
  explicit S_RETURNDRONE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_RETURNDRONE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_RETURNDRONE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_RETURNDRONE) */ {
 public:
  inline C_RETURNDRONE() : C_RETURNDRONE(nullptr) {}
  ~C_RETURNDRONE() override;
  explicit PROTOBUF_CONSTEXPR C_RETURNDRONE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_RETURNDRONE(const C_RETURNDRONE& from);
  C_RETURNDRONE(C_RETURNDRONE&& from) noexcept
    : C_RETURNDRONE() {
    *this = ::std::move(from);
  }

  inline C_RETURNDRONE& operator=(const C_RETURNDRONE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_RETURNDRONE& operator=(C_RETURNDRONE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_RETURNDRONE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_RETURNDRONE* internal_default_instance() {
    return reinterpret_cast<const C_RETURNDRONE*>(
               &_C_RETURNDRONE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(C_RETURNDRONE& a, C_RETURNDRONE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_RETURNDRONE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_RETURNDRONE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_RETURNDRONE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_RETURNDRONE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_RETURNDRONE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_RETURNDRONE& from) {
    C_RETURNDRONE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_RETURNDRONE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_RETURNDRONE";
  }
  protected:
  explicit C_RETURNDRONE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_RETURNDRONE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ATTACKDRONE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ATTACKDRONE) */ {
 public:
  inline S_ATTACKDRONE() : S_ATTACKDRONE(nullptr) {}
  ~S_ATTACKDRONE() override;
  explicit PROTOBUF_CONSTEXPR S_ATTACKDRONE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ATTACKDRONE(const S_ATTACKDRONE& from);
  S_ATTACKDRONE(S_ATTACKDRONE&& from) noexcept
    : S_ATTACKDRONE() {
    *this = ::std::move(from);
  }

  inline S_ATTACKDRONE& operator=(const S_ATTACKDRONE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ATTACKDRONE& operator=(S_ATTACKDRONE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ATTACKDRONE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ATTACKDRONE* internal_default_instance() {
    return reinterpret_cast<const S_ATTACKDRONE*>(
               &_S_ATTACKDRONE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(S_ATTACKDRONE& a, S_ATTACKDRONE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ATTACKDRONE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ATTACKDRONE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ATTACKDRONE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ATTACKDRONE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ATTACKDRONE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ATTACKDRONE& from) {
    S_ATTACKDRONE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ATTACKDRONE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ATTACKDRONE";
  }
  protected:
  explicit S_ATTACKDRONE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ATTACKDRONE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ATTACKDRONE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ATTACKDRONE) */ {
 public:
  inline C_ATTACKDRONE() : C_ATTACKDRONE(nullptr) {}
  ~C_ATTACKDRONE() override;
  explicit PROTOBUF_CONSTEXPR C_ATTACKDRONE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ATTACKDRONE(const C_ATTACKDRONE& from);
  C_ATTACKDRONE(C_ATTACKDRONE&& from) noexcept
    : C_ATTACKDRONE() {
    *this = ::std::move(from);
  }

  inline C_ATTACKDRONE& operator=(const C_ATTACKDRONE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ATTACKDRONE& operator=(C_ATTACKDRONE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ATTACKDRONE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ATTACKDRONE* internal_default_instance() {
    return reinterpret_cast<const C_ATTACKDRONE*>(
               &_C_ATTACKDRONE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(C_ATTACKDRONE& a, C_ATTACKDRONE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ATTACKDRONE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ATTACKDRONE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ATTACKDRONE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ATTACKDRONE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ATTACKDRONE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ATTACKDRONE& from) {
    C_ATTACKDRONE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ATTACKDRONE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ATTACKDRONE";
  }
  protected:
  explicit C_ATTACKDRONE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ATTACKDRONE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EATITEM_MAXHPUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EATITEM_MAXHPUP) */ {
 public:
  inline S_EATITEM_MAXHPUP() : S_EATITEM_MAXHPUP(nullptr) {}
  ~S_EATITEM_MAXHPUP() override;
  explicit PROTOBUF_CONSTEXPR S_EATITEM_MAXHPUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EATITEM_MAXHPUP(const S_EATITEM_MAXHPUP& from);
  S_EATITEM_MAXHPUP(S_EATITEM_MAXHPUP&& from) noexcept
    : S_EATITEM_MAXHPUP() {
    *this = ::std::move(from);
  }

  inline S_EATITEM_MAXHPUP& operator=(const S_EATITEM_MAXHPUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EATITEM_MAXHPUP& operator=(S_EATITEM_MAXHPUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EATITEM_MAXHPUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EATITEM_MAXHPUP* internal_default_instance() {
    return reinterpret_cast<const S_EATITEM_MAXHPUP*>(
               &_S_EATITEM_MAXHPUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(S_EATITEM_MAXHPUP& a, S_EATITEM_MAXHPUP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EATITEM_MAXHPUP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EATITEM_MAXHPUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EATITEM_MAXHPUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EATITEM_MAXHPUP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EATITEM_MAXHPUP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EATITEM_MAXHPUP& from) {
    S_EATITEM_MAXHPUP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EATITEM_MAXHPUP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EATITEM_MAXHPUP";
  }
  protected:
  explicit S_EATITEM_MAXHPUP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kMaxHPFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float maxHP = 2;
  void clear_maxhp();
  float maxhp() const;
  void set_maxhp(float value);
  private:
  float _internal_maxhp() const;
  void _internal_set_maxhp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EATITEM_MAXHPUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float maxhp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EATITEM_MAXHPUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EATITEM_MAXHPUP) */ {
 public:
  inline C_EATITEM_MAXHPUP() : C_EATITEM_MAXHPUP(nullptr) {}
  ~C_EATITEM_MAXHPUP() override;
  explicit PROTOBUF_CONSTEXPR C_EATITEM_MAXHPUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EATITEM_MAXHPUP(const C_EATITEM_MAXHPUP& from);
  C_EATITEM_MAXHPUP(C_EATITEM_MAXHPUP&& from) noexcept
    : C_EATITEM_MAXHPUP() {
    *this = ::std::move(from);
  }

  inline C_EATITEM_MAXHPUP& operator=(const C_EATITEM_MAXHPUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EATITEM_MAXHPUP& operator=(C_EATITEM_MAXHPUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EATITEM_MAXHPUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EATITEM_MAXHPUP* internal_default_instance() {
    return reinterpret_cast<const C_EATITEM_MAXHPUP*>(
               &_C_EATITEM_MAXHPUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(C_EATITEM_MAXHPUP& a, C_EATITEM_MAXHPUP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EATITEM_MAXHPUP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EATITEM_MAXHPUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EATITEM_MAXHPUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EATITEM_MAXHPUP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EATITEM_MAXHPUP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_EATITEM_MAXHPUP& from) {
    C_EATITEM_MAXHPUP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EATITEM_MAXHPUP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EATITEM_MAXHPUP";
  }
  protected:
  explicit C_EATITEM_MAXHPUP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kMaxHPFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float maxHP = 2;
  void clear_maxhp();
  float maxhp() const;
  void set_maxhp(float value);
  private:
  float _internal_maxhp() const;
  void _internal_set_maxhp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EATITEM_MAXHPUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float maxhp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EATITEM_LVUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EATITEM_LVUP) */ {
 public:
  inline S_EATITEM_LVUP() : S_EATITEM_LVUP(nullptr) {}
  ~S_EATITEM_LVUP() override;
  explicit PROTOBUF_CONSTEXPR S_EATITEM_LVUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EATITEM_LVUP(const S_EATITEM_LVUP& from);
  S_EATITEM_LVUP(S_EATITEM_LVUP&& from) noexcept
    : S_EATITEM_LVUP() {
    *this = ::std::move(from);
  }

  inline S_EATITEM_LVUP& operator=(const S_EATITEM_LVUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EATITEM_LVUP& operator=(S_EATITEM_LVUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EATITEM_LVUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EATITEM_LVUP* internal_default_instance() {
    return reinterpret_cast<const S_EATITEM_LVUP*>(
               &_S_EATITEM_LVUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(S_EATITEM_LVUP& a, S_EATITEM_LVUP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EATITEM_LVUP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EATITEM_LVUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EATITEM_LVUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EATITEM_LVUP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EATITEM_LVUP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EATITEM_LVUP& from) {
    S_EATITEM_LVUP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EATITEM_LVUP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EATITEM_LVUP";
  }
  protected:
  explicit S_EATITEM_LVUP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kCurLVFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // int64 curLV = 2;
  void clear_curlv();
  int64_t curlv() const;
  void set_curlv(int64_t value);
  private:
  int64_t _internal_curlv() const;
  void _internal_set_curlv(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EATITEM_LVUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int64_t curlv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EATITEM_LVUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EATITEM_LVUP) */ {
 public:
  inline C_EATITEM_LVUP() : C_EATITEM_LVUP(nullptr) {}
  ~C_EATITEM_LVUP() override;
  explicit PROTOBUF_CONSTEXPR C_EATITEM_LVUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EATITEM_LVUP(const C_EATITEM_LVUP& from);
  C_EATITEM_LVUP(C_EATITEM_LVUP&& from) noexcept
    : C_EATITEM_LVUP() {
    *this = ::std::move(from);
  }

  inline C_EATITEM_LVUP& operator=(const C_EATITEM_LVUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EATITEM_LVUP& operator=(C_EATITEM_LVUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EATITEM_LVUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EATITEM_LVUP* internal_default_instance() {
    return reinterpret_cast<const C_EATITEM_LVUP*>(
               &_C_EATITEM_LVUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(C_EATITEM_LVUP& a, C_EATITEM_LVUP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EATITEM_LVUP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EATITEM_LVUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EATITEM_LVUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EATITEM_LVUP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EATITEM_LVUP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_EATITEM_LVUP& from) {
    C_EATITEM_LVUP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EATITEM_LVUP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EATITEM_LVUP";
  }
  protected:
  explicit C_EATITEM_LVUP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kCurLVFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // int64 curLV = 2;
  void clear_curlv();
  int64_t curlv() const;
  void set_curlv(int64_t value);
  private:
  int64_t _internal_curlv() const;
  void _internal_set_curlv(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EATITEM_LVUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int64_t curlv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EATITEM_DMGUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EATITEM_DMGUP) */ {
 public:
  inline S_EATITEM_DMGUP() : S_EATITEM_DMGUP(nullptr) {}
  ~S_EATITEM_DMGUP() override;
  explicit PROTOBUF_CONSTEXPR S_EATITEM_DMGUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EATITEM_DMGUP(const S_EATITEM_DMGUP& from);
  S_EATITEM_DMGUP(S_EATITEM_DMGUP&& from) noexcept
    : S_EATITEM_DMGUP() {
    *this = ::std::move(from);
  }

  inline S_EATITEM_DMGUP& operator=(const S_EATITEM_DMGUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EATITEM_DMGUP& operator=(S_EATITEM_DMGUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EATITEM_DMGUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EATITEM_DMGUP* internal_default_instance() {
    return reinterpret_cast<const S_EATITEM_DMGUP*>(
               &_S_EATITEM_DMGUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(S_EATITEM_DMGUP& a, S_EATITEM_DMGUP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EATITEM_DMGUP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EATITEM_DMGUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EATITEM_DMGUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EATITEM_DMGUP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EATITEM_DMGUP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EATITEM_DMGUP& from) {
    S_EATITEM_DMGUP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EATITEM_DMGUP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EATITEM_DMGUP";
  }
  protected:
  explicit S_EATITEM_DMGUP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAttackDmgFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float attackDmg = 2;
  void clear_attackdmg();
  float attackdmg() const;
  void set_attackdmg(float value);
  private:
  float _internal_attackdmg() const;
  void _internal_set_attackdmg(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EATITEM_DMGUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float attackdmg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EATITEM_DMGUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EATITEM_DMGUP) */ {
 public:
  inline C_EATITEM_DMGUP() : C_EATITEM_DMGUP(nullptr) {}
  ~C_EATITEM_DMGUP() override;
  explicit PROTOBUF_CONSTEXPR C_EATITEM_DMGUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EATITEM_DMGUP(const C_EATITEM_DMGUP& from);
  C_EATITEM_DMGUP(C_EATITEM_DMGUP&& from) noexcept
    : C_EATITEM_DMGUP() {
    *this = ::std::move(from);
  }

  inline C_EATITEM_DMGUP& operator=(const C_EATITEM_DMGUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EATITEM_DMGUP& operator=(C_EATITEM_DMGUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EATITEM_DMGUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EATITEM_DMGUP* internal_default_instance() {
    return reinterpret_cast<const C_EATITEM_DMGUP*>(
               &_C_EATITEM_DMGUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(C_EATITEM_DMGUP& a, C_EATITEM_DMGUP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EATITEM_DMGUP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EATITEM_DMGUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EATITEM_DMGUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EATITEM_DMGUP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EATITEM_DMGUP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_EATITEM_DMGUP& from) {
    C_EATITEM_DMGUP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EATITEM_DMGUP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EATITEM_DMGUP";
  }
  protected:
  explicit C_EATITEM_DMGUP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kAttackDmgFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float attackDmg = 2;
  void clear_attackdmg();
  float attackdmg() const;
  void set_attackdmg(float value);
  private:
  float _internal_attackdmg() const;
  void _internal_set_attackdmg(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EATITEM_DMGUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float attackdmg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EATITEM_HEALHP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EATITEM_HEALHP) */ {
 public:
  inline S_EATITEM_HEALHP() : S_EATITEM_HEALHP(nullptr) {}
  ~S_EATITEM_HEALHP() override;
  explicit PROTOBUF_CONSTEXPR S_EATITEM_HEALHP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EATITEM_HEALHP(const S_EATITEM_HEALHP& from);
  S_EATITEM_HEALHP(S_EATITEM_HEALHP&& from) noexcept
    : S_EATITEM_HEALHP() {
    *this = ::std::move(from);
  }

  inline S_EATITEM_HEALHP& operator=(const S_EATITEM_HEALHP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EATITEM_HEALHP& operator=(S_EATITEM_HEALHP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EATITEM_HEALHP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EATITEM_HEALHP* internal_default_instance() {
    return reinterpret_cast<const S_EATITEM_HEALHP*>(
               &_S_EATITEM_HEALHP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(S_EATITEM_HEALHP& a, S_EATITEM_HEALHP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EATITEM_HEALHP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EATITEM_HEALHP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EATITEM_HEALHP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EATITEM_HEALHP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EATITEM_HEALHP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EATITEM_HEALHP& from) {
    S_EATITEM_HEALHP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EATITEM_HEALHP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EATITEM_HEALHP";
  }
  protected:
  explicit S_EATITEM_HEALHP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kCurHPFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float curHP = 2;
  void clear_curhp();
  float curhp() const;
  void set_curhp(float value);
  private:
  float _internal_curhp() const;
  void _internal_set_curhp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EATITEM_HEALHP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float curhp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EATITEM_HEALHP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EATITEM_HEALHP) */ {
 public:
  inline C_EATITEM_HEALHP() : C_EATITEM_HEALHP(nullptr) {}
  ~C_EATITEM_HEALHP() override;
  explicit PROTOBUF_CONSTEXPR C_EATITEM_HEALHP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EATITEM_HEALHP(const C_EATITEM_HEALHP& from);
  C_EATITEM_HEALHP(C_EATITEM_HEALHP&& from) noexcept
    : C_EATITEM_HEALHP() {
    *this = ::std::move(from);
  }

  inline C_EATITEM_HEALHP& operator=(const C_EATITEM_HEALHP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EATITEM_HEALHP& operator=(C_EATITEM_HEALHP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EATITEM_HEALHP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EATITEM_HEALHP* internal_default_instance() {
    return reinterpret_cast<const C_EATITEM_HEALHP*>(
               &_C_EATITEM_HEALHP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(C_EATITEM_HEALHP& a, C_EATITEM_HEALHP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EATITEM_HEALHP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EATITEM_HEALHP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EATITEM_HEALHP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EATITEM_HEALHP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EATITEM_HEALHP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_EATITEM_HEALHP& from) {
    C_EATITEM_HEALHP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EATITEM_HEALHP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EATITEM_HEALHP";
  }
  protected:
  explicit C_EATITEM_HEALHP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kCurHPFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // float curHP = 2;
  void clear_curhp();
  float curhp() const;
  void set_curhp(float value);
  private:
  float _internal_curhp() const;
  void _internal_set_curhp(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EATITEM_HEALHP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    float curhp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SET_MAGNETICFIELD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SET_MAGNETICFIELD) */ {
 public:
  inline S_SET_MAGNETICFIELD() : S_SET_MAGNETICFIELD(nullptr) {}
  ~S_SET_MAGNETICFIELD() override;
  explicit PROTOBUF_CONSTEXPR S_SET_MAGNETICFIELD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SET_MAGNETICFIELD(const S_SET_MAGNETICFIELD& from);
  S_SET_MAGNETICFIELD(S_SET_MAGNETICFIELD&& from) noexcept
    : S_SET_MAGNETICFIELD() {
    *this = ::std::move(from);
  }

  inline S_SET_MAGNETICFIELD& operator=(const S_SET_MAGNETICFIELD& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SET_MAGNETICFIELD& operator=(S_SET_MAGNETICFIELD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SET_MAGNETICFIELD& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SET_MAGNETICFIELD* internal_default_instance() {
    return reinterpret_cast<const S_SET_MAGNETICFIELD*>(
               &_S_SET_MAGNETICFIELD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(S_SET_MAGNETICFIELD& a, S_SET_MAGNETICFIELD& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SET_MAGNETICFIELD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SET_MAGNETICFIELD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SET_MAGNETICFIELD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SET_MAGNETICFIELD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SET_MAGNETICFIELD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SET_MAGNETICFIELD& from) {
    S_SET_MAGNETICFIELD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SET_MAGNETICFIELD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SET_MAGNETICFIELD";
  }
  protected:
  explicit S_SET_MAGNETICFIELD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
    kRadiusFieldNumber = 5,
    kTimeFieldNumber = 6,
  };
  // float r = 1;
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // float g = 2;
  void clear_g();
  float g() const;
  void set_g(float value);
  private:
  float _internal_g() const;
  void _internal_set_g(float value);
  public:

  // float b = 3;
  void clear_b();
  float b() const;
  void set_b(float value);
  private:
  float _internal_b() const;
  void _internal_set_b(float value);
  public:

  // float a = 4;
  void clear_a();
  float a() const;
  void set_a(float value);
  private:
  float _internal_a() const;
  void _internal_set_a(float value);
  public:

  // float radius = 5;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // float time = 6;
  void clear_time();
  float time() const;
  void set_time(float value);
  private:
  float _internal_time() const;
  void _internal_set_time(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SET_MAGNETICFIELD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float r_;
    float g_;
    float b_;
    float a_;
    float radius_;
    float time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SET_MAGNETICFIELD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SET_MAGNETICFIELD) */ {
 public:
  inline C_SET_MAGNETICFIELD() : C_SET_MAGNETICFIELD(nullptr) {}
  ~C_SET_MAGNETICFIELD() override;
  explicit PROTOBUF_CONSTEXPR C_SET_MAGNETICFIELD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SET_MAGNETICFIELD(const C_SET_MAGNETICFIELD& from);
  C_SET_MAGNETICFIELD(C_SET_MAGNETICFIELD&& from) noexcept
    : C_SET_MAGNETICFIELD() {
    *this = ::std::move(from);
  }

  inline C_SET_MAGNETICFIELD& operator=(const C_SET_MAGNETICFIELD& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SET_MAGNETICFIELD& operator=(C_SET_MAGNETICFIELD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SET_MAGNETICFIELD& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SET_MAGNETICFIELD* internal_default_instance() {
    return reinterpret_cast<const C_SET_MAGNETICFIELD*>(
               &_C_SET_MAGNETICFIELD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(C_SET_MAGNETICFIELD& a, C_SET_MAGNETICFIELD& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SET_MAGNETICFIELD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SET_MAGNETICFIELD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SET_MAGNETICFIELD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SET_MAGNETICFIELD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SET_MAGNETICFIELD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_SET_MAGNETICFIELD& from) {
    C_SET_MAGNETICFIELD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SET_MAGNETICFIELD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SET_MAGNETICFIELD";
  }
  protected:
  explicit C_SET_MAGNETICFIELD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
    kRadiusFieldNumber = 5,
    kTimeFieldNumber = 6,
  };
  // float r = 1;
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // float g = 2;
  void clear_g();
  float g() const;
  void set_g(float value);
  private:
  float _internal_g() const;
  void _internal_set_g(float value);
  public:

  // float b = 3;
  void clear_b();
  float b() const;
  void set_b(float value);
  private:
  float _internal_b() const;
  void _internal_set_b(float value);
  public:

  // float a = 4;
  void clear_a();
  float a() const;
  void set_a(float value);
  private:
  float _internal_a() const;
  void _internal_set_a(float value);
  public:

  // float radius = 5;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // float time = 6;
  void clear_time();
  float time() const;
  void set_time(float value);
  private:
  float _internal_time() const;
  void _internal_set_time(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SET_MAGNETICFIELD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float r_;
    float g_;
    float b_;
    float a_;
    float radius_;
    float time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_WORLD_LVUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_WORLD_LVUP) */ {
 public:
  inline S_WORLD_LVUP() : S_WORLD_LVUP(nullptr) {}
  ~S_WORLD_LVUP() override;
  explicit PROTOBUF_CONSTEXPR S_WORLD_LVUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_WORLD_LVUP(const S_WORLD_LVUP& from);
  S_WORLD_LVUP(S_WORLD_LVUP&& from) noexcept
    : S_WORLD_LVUP() {
    *this = ::std::move(from);
  }

  inline S_WORLD_LVUP& operator=(const S_WORLD_LVUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_WORLD_LVUP& operator=(S_WORLD_LVUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_WORLD_LVUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_WORLD_LVUP* internal_default_instance() {
    return reinterpret_cast<const S_WORLD_LVUP*>(
               &_S_WORLD_LVUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(S_WORLD_LVUP& a, S_WORLD_LVUP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_WORLD_LVUP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_WORLD_LVUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_WORLD_LVUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_WORLD_LVUP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_WORLD_LVUP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_WORLD_LVUP& from) {
    S_WORLD_LVUP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_WORLD_LVUP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_WORLD_LVUP";
  }
  protected:
  explicit S_WORLD_LVUP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldLevelFieldNumber = 1,
  };
  // int64 worldLevel = 1;
  void clear_worldlevel();
  int64_t worldlevel() const;
  void set_worldlevel(int64_t value);
  private:
  int64_t _internal_worldlevel() const;
  void _internal_set_worldlevel(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_WORLD_LVUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t worldlevel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_WORLD_LVUP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_WORLD_LVUP) */ {
 public:
  inline C_WORLD_LVUP() : C_WORLD_LVUP(nullptr) {}
  ~C_WORLD_LVUP() override;
  explicit PROTOBUF_CONSTEXPR C_WORLD_LVUP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_WORLD_LVUP(const C_WORLD_LVUP& from);
  C_WORLD_LVUP(C_WORLD_LVUP&& from) noexcept
    : C_WORLD_LVUP() {
    *this = ::std::move(from);
  }

  inline C_WORLD_LVUP& operator=(const C_WORLD_LVUP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_WORLD_LVUP& operator=(C_WORLD_LVUP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_WORLD_LVUP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_WORLD_LVUP* internal_default_instance() {
    return reinterpret_cast<const C_WORLD_LVUP*>(
               &_C_WORLD_LVUP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(C_WORLD_LVUP& a, C_WORLD_LVUP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_WORLD_LVUP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_WORLD_LVUP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_WORLD_LVUP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_WORLD_LVUP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_WORLD_LVUP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_WORLD_LVUP& from) {
    C_WORLD_LVUP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_WORLD_LVUP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_WORLD_LVUP";
  }
  protected:
  explicit C_WORLD_LVUP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldLevelFieldNumber = 1,
  };
  // int64 worldLevel = 1;
  void clear_worldlevel();
  int64_t worldlevel() const;
  void set_worldlevel(int64_t value);
  private:
  int64_t _internal_worldlevel() const;
  void _internal_set_worldlevel(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_WORLD_LVUP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t worldlevel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_GAMERESULT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_GAMERESULT) */ {
 public:
  inline S_GAMERESULT() : S_GAMERESULT(nullptr) {}
  ~S_GAMERESULT() override;
  explicit PROTOBUF_CONSTEXPR S_GAMERESULT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_GAMERESULT(const S_GAMERESULT& from);
  S_GAMERESULT(S_GAMERESULT&& from) noexcept
    : S_GAMERESULT() {
    *this = ::std::move(from);
  }

  inline S_GAMERESULT& operator=(const S_GAMERESULT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_GAMERESULT& operator=(S_GAMERESULT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_GAMERESULT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_GAMERESULT* internal_default_instance() {
    return reinterpret_cast<const S_GAMERESULT*>(
               &_S_GAMERESULT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(S_GAMERESULT& a, S_GAMERESULT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_GAMERESULT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_GAMERESULT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_GAMERESULT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_GAMERESULT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_GAMERESULT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_GAMERESULT& from) {
    S_GAMERESULT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_GAMERESULT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_GAMERESULT";
  }
  protected:
  explicit S_GAMERESULT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_GAMERESULT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_GAMERESULT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_GAMERESULT) */ {
 public:
  inline C_GAMERESULT() : C_GAMERESULT(nullptr) {}
  ~C_GAMERESULT() override;
  explicit PROTOBUF_CONSTEXPR C_GAMERESULT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_GAMERESULT(const C_GAMERESULT& from);
  C_GAMERESULT(C_GAMERESULT&& from) noexcept
    : C_GAMERESULT() {
    *this = ::std::move(from);
  }

  inline C_GAMERESULT& operator=(const C_GAMERESULT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_GAMERESULT& operator=(C_GAMERESULT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_GAMERESULT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_GAMERESULT* internal_default_instance() {
    return reinterpret_cast<const C_GAMERESULT*>(
               &_C_GAMERESULT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(C_GAMERESULT& a, C_GAMERESULT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_GAMERESULT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_GAMERESULT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_GAMERESULT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_GAMERESULT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_GAMERESULT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_GAMERESULT& from) {
    C_GAMERESULT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_GAMERESULT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_GAMERESULT";
  }
  protected:
  explicit C_GAMERESULT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_GAMERESULT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_LOGIN

// -------------------------------------------------------------------

// S_LOGIN

// uint64 client_ID = 1;
inline void S_LOGIN::clear_client_id() {
  _impl_.client_id_ = uint64_t{0u};
}
inline uint64_t S_LOGIN::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint64_t S_LOGIN::client_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.client_ID)
  return _internal_client_id();
}
inline void S_LOGIN::_internal_set_client_id(uint64_t value) {
  
  _impl_.client_id_ = value;
}
inline void S_LOGIN::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOGIN.client_ID)
}

// -------------------------------------------------------------------

// C_PLAYERSPAWNPOINT

// uint64 SpawnPointSize = 1;
inline void C_PLAYERSPAWNPOINT::clear_spawnpointsize() {
  _impl_.spawnpointsize_ = uint64_t{0u};
}
inline uint64_t C_PLAYERSPAWNPOINT::_internal_spawnpointsize() const {
  return _impl_.spawnpointsize_;
}
inline uint64_t C_PLAYERSPAWNPOINT::spawnpointsize() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSPAWNPOINT.SpawnPointSize)
  return _internal_spawnpointsize();
}
inline void C_PLAYERSPAWNPOINT::_internal_set_spawnpointsize(uint64_t value) {
  
  _impl_.spawnpointsize_ = value;
}
inline void C_PLAYERSPAWNPOINT::set_spawnpointsize(uint64_t value) {
  _internal_set_spawnpointsize(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSPAWNPOINT.SpawnPointSize)
}

// -------------------------------------------------------------------

// S_PLAYERCOUNT

// uint64 playerCount = 1;
inline void S_PLAYERCOUNT::clear_playercount() {
  _impl_.playercount_ = uint64_t{0u};
}
inline uint64_t S_PLAYERCOUNT::_internal_playercount() const {
  return _impl_.playercount_;
}
inline uint64_t S_PLAYERCOUNT::playercount() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERCOUNT.playerCount)
  return _internal_playercount();
}
inline void S_PLAYERCOUNT::_internal_set_playercount(uint64_t value) {
  
  _impl_.playercount_ = value;
}
inline void S_PLAYERCOUNT::set_playercount(uint64_t value) {
  _internal_set_playercount(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERCOUNT.playerCount)
}

// -------------------------------------------------------------------

// C_PLAYERCOUNT

// -------------------------------------------------------------------

// C_GAMESTART

// -------------------------------------------------------------------

// S_GAMESTART

// -------------------------------------------------------------------

// C_ENTER_GAME

// uint64 client_ID = 1;
inline void C_ENTER_GAME::clear_client_id() {
  _impl_.client_id_ = uint64_t{0u};
}
inline uint64_t C_ENTER_GAME::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint64_t C_ENTER_GAME::client_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER_GAME.client_ID)
  return _internal_client_id();
}
inline void C_ENTER_GAME::_internal_set_client_id(uint64_t value) {
  
  _impl_.client_id_ = value;
}
inline void C_ENTER_GAME::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER_GAME.client_ID)
}

// -------------------------------------------------------------------

// S_ENTER_GAME

// .Protocol.ObjectInfo player = 1;
inline bool S_ENTER_GAME::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool S_ENTER_GAME::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::ObjectInfo& S_ENTER_GAME::_internal_player() const {
  const ::Protocol::ObjectInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_ENTER_GAME::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.player)
  return _internal_player();
}
inline void S_ENTER_GAME::unsafe_arena_set_allocated_player(
    ::Protocol::ObjectInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ENTER_GAME.player)
}
inline ::Protocol::ObjectInfo* S_ENTER_GAME::release_player() {
  
  ::Protocol::ObjectInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_ENTER_GAME::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_ENTER_GAME.player)
  
  ::Protocol::ObjectInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_ENTER_GAME::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::Protocol::ObjectInfo* S_ENTER_GAME::mutable_player() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_GAME.player)
  return _msg;
}
inline void S_ENTER_GAME::set_allocated_player(::Protocol::ObjectInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ENTER_GAME.player)
}

// uint64 spawnIdx = 2;
inline void S_ENTER_GAME::clear_spawnidx() {
  _impl_.spawnidx_ = uint64_t{0u};
}
inline uint64_t S_ENTER_GAME::_internal_spawnidx() const {
  return _impl_.spawnidx_;
}
inline uint64_t S_ENTER_GAME::spawnidx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.spawnIdx)
  return _internal_spawnidx();
}
inline void S_ENTER_GAME::_internal_set_spawnidx(uint64_t value) {
  
  _impl_.spawnidx_ = value;
}
inline void S_ENTER_GAME::set_spawnidx(uint64_t value) {
  _internal_set_spawnidx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENTER_GAME.spawnIdx)
}

// -------------------------------------------------------------------

// C_LEAVE_GAME

// -------------------------------------------------------------------

// S_LEAVE_GAME

// -------------------------------------------------------------------

// S_SPAWN

// repeated .Protocol.ObjectInfo players = 1;
inline int S_SPAWN::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int S_SPAWN::players_size() const {
  return _internal_players_size();
}
inline ::Protocol::ObjectInfo* S_SPAWN::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
S_SPAWN::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWN.players)
  return &_impl_.players_;
}
inline const ::Protocol::ObjectInfo& S_SPAWN::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::ObjectInfo& S_SPAWN::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.players)
  return _internal_players(index);
}
inline ::Protocol::ObjectInfo* S_SPAWN::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::ObjectInfo* S_SPAWN::add_players() {
  ::Protocol::ObjectInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
S_SPAWN::players() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWN.players)
  return _impl_.players_;
}

// uint64 spawnIdx = 2;
inline void S_SPAWN::clear_spawnidx() {
  _impl_.spawnidx_ = uint64_t{0u};
}
inline uint64_t S_SPAWN::_internal_spawnidx() const {
  return _impl_.spawnidx_;
}
inline uint64_t S_SPAWN::spawnidx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.spawnIdx)
  return _internal_spawnidx();
}
inline void S_SPAWN::_internal_set_spawnidx(uint64_t value) {
  
  _impl_.spawnidx_ = value;
}
inline void S_SPAWN::set_spawnidx(uint64_t value) {
  _internal_set_spawnidx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SPAWN.spawnIdx)
}

// -------------------------------------------------------------------

// S_DESPAWN

// repeated uint64 object_ids = 1;
inline int S_DESPAWN::_internal_object_ids_size() const {
  return _impl_.object_ids_.size();
}
inline int S_DESPAWN::object_ids_size() const {
  return _internal_object_ids_size();
}
inline void S_DESPAWN::clear_object_ids() {
  _impl_.object_ids_.Clear();
}
inline uint64_t S_DESPAWN::_internal_object_ids(int index) const {
  return _impl_.object_ids_.Get(index);
}
inline uint64_t S_DESPAWN::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_DESPAWN.object_ids)
  return _internal_object_ids(index);
}
inline void S_DESPAWN::set_object_ids(int index, uint64_t value) {
  _impl_.object_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_DESPAWN.object_ids)
}
inline void S_DESPAWN::_internal_add_object_ids(uint64_t value) {
  _impl_.object_ids_.Add(value);
}
inline void S_DESPAWN::add_object_ids(uint64_t value) {
  _internal_add_object_ids(value);
  // @@protoc_insertion_point(field_add:Protocol.S_DESPAWN.object_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_DESPAWN::_internal_object_ids() const {
  return _impl_.object_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_DESPAWN::object_ids() const {
  // @@protoc_insertion_point(field_list:Protocol.S_DESPAWN.object_ids)
  return _internal_object_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_DESPAWN::_internal_mutable_object_ids() {
  return &_impl_.object_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_DESPAWN::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_DESPAWN.object_ids)
  return _internal_mutable_object_ids();
}

// -------------------------------------------------------------------

// C_MOVE

// .Protocol.PosInfo info = 1;
inline bool C_MOVE::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool C_MOVE::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::PosInfo& C_MOVE::_internal_info() const {
  const ::Protocol::PosInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& C_MOVE::info() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVE.info)
  return _internal_info();
}
inline void C_MOVE::unsafe_arena_set_allocated_info(
    ::Protocol::PosInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_MOVE.info)
}
inline ::Protocol::PosInfo* C_MOVE::release_info() {
  
  ::Protocol::PosInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* C_MOVE::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.C_MOVE.info)
  
  ::Protocol::PosInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* C_MOVE::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::PosInfo* C_MOVE::mutable_info() {
  ::Protocol::PosInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.C_MOVE.info)
  return _msg;
}
inline void C_MOVE::set_allocated_info(::Protocol::PosInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_MOVE.info)
}

// -------------------------------------------------------------------

// S_MOVE

// .Protocol.PosInfo info = 1;
inline bool S_MOVE::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_MOVE::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::PosInfo& S_MOVE::_internal_info() const {
  const ::Protocol::PosInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& S_MOVE::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.info)
  return _internal_info();
}
inline void S_MOVE::unsafe_arena_set_allocated_info(
    ::Protocol::PosInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MOVE.info)
}
inline ::Protocol::PosInfo* S_MOVE::release_info() {
  
  ::Protocol::PosInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* S_MOVE::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_MOVE.info)
  
  ::Protocol::PosInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* S_MOVE::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::PosInfo* S_MOVE::mutable_info() {
  ::Protocol::PosInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_MOVE.info)
  return _msg;
}
inline void S_MOVE::set_allocated_info(::Protocol::PosInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MOVE.info)
}

// -------------------------------------------------------------------

// C_CHAT

// string msg = 1;
inline void C_CHAT::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& C_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CHAT.msg)
}
inline std::string* C_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CHAT.msg)
  return _s;
}
inline const std::string& C_CHAT::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void C_CHAT::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CHAT::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.C_CHAT.msg)
  return _impl_.msg_.Release();
}
inline void C_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CHAT.msg)
}

// -------------------------------------------------------------------

// S_CHAT

// uint64 playerId = 1;
inline void S_CHAT::clear_playerid() {
  _impl_.playerid_ = uint64_t{0u};
}
inline uint64_t S_CHAT::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint64_t S_CHAT::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.playerId)
  return _internal_playerid();
}
inline void S_CHAT::_internal_set_playerid(uint64_t value) {
  
  _impl_.playerid_ = value;
}
inline void S_CHAT::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.playerId)
}

// string msg = 2;
inline void S_CHAT::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& S_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.msg)
}
inline std::string* S_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHAT.msg)
  return _s;
}
inline const std::string& S_CHAT::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void S_CHAT::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CHAT::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.S_CHAT.msg)
  return _impl_.msg_.Release();
}
inline void S_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CHAT.msg)
}

// -------------------------------------------------------------------

// C_FIRE

// .Protocol.ProjectileInfo projectile = 1;
inline bool C_FIRE::_internal_has_projectile() const {
  return this != internal_default_instance() && _impl_.projectile_ != nullptr;
}
inline bool C_FIRE::has_projectile() const {
  return _internal_has_projectile();
}
inline const ::Protocol::ProjectileInfo& C_FIRE::_internal_projectile() const {
  const ::Protocol::ProjectileInfo* p = _impl_.projectile_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ProjectileInfo&>(
      ::Protocol::_ProjectileInfo_default_instance_);
}
inline const ::Protocol::ProjectileInfo& C_FIRE::projectile() const {
  // @@protoc_insertion_point(field_get:Protocol.C_FIRE.projectile)
  return _internal_projectile();
}
inline void C_FIRE::unsafe_arena_set_allocated_projectile(
    ::Protocol::ProjectileInfo* projectile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectile_);
  }
  _impl_.projectile_ = projectile;
  if (projectile) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_FIRE.projectile)
}
inline ::Protocol::ProjectileInfo* C_FIRE::release_projectile() {
  
  ::Protocol::ProjectileInfo* temp = _impl_.projectile_;
  _impl_.projectile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ProjectileInfo* C_FIRE::unsafe_arena_release_projectile() {
  // @@protoc_insertion_point(field_release:Protocol.C_FIRE.projectile)
  
  ::Protocol::ProjectileInfo* temp = _impl_.projectile_;
  _impl_.projectile_ = nullptr;
  return temp;
}
inline ::Protocol::ProjectileInfo* C_FIRE::_internal_mutable_projectile() {
  
  if (_impl_.projectile_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ProjectileInfo>(GetArenaForAllocation());
    _impl_.projectile_ = p;
  }
  return _impl_.projectile_;
}
inline ::Protocol::ProjectileInfo* C_FIRE::mutable_projectile() {
  ::Protocol::ProjectileInfo* _msg = _internal_mutable_projectile();
  // @@protoc_insertion_point(field_mutable:Protocol.C_FIRE.projectile)
  return _msg;
}
inline void C_FIRE::set_allocated_projectile(::Protocol::ProjectileInfo* projectile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectile_);
  }
  if (projectile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(projectile));
    if (message_arena != submessage_arena) {
      projectile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projectile, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.projectile_ = projectile;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_FIRE.projectile)
}

// -------------------------------------------------------------------

// S_FIRE

// .Protocol.ProjectileInfo projectile = 1;
inline bool S_FIRE::_internal_has_projectile() const {
  return this != internal_default_instance() && _impl_.projectile_ != nullptr;
}
inline bool S_FIRE::has_projectile() const {
  return _internal_has_projectile();
}
inline const ::Protocol::ProjectileInfo& S_FIRE::_internal_projectile() const {
  const ::Protocol::ProjectileInfo* p = _impl_.projectile_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ProjectileInfo&>(
      ::Protocol::_ProjectileInfo_default_instance_);
}
inline const ::Protocol::ProjectileInfo& S_FIRE::projectile() const {
  // @@protoc_insertion_point(field_get:Protocol.S_FIRE.projectile)
  return _internal_projectile();
}
inline void S_FIRE::unsafe_arena_set_allocated_projectile(
    ::Protocol::ProjectileInfo* projectile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectile_);
  }
  _impl_.projectile_ = projectile;
  if (projectile) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_FIRE.projectile)
}
inline ::Protocol::ProjectileInfo* S_FIRE::release_projectile() {
  
  ::Protocol::ProjectileInfo* temp = _impl_.projectile_;
  _impl_.projectile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ProjectileInfo* S_FIRE::unsafe_arena_release_projectile() {
  // @@protoc_insertion_point(field_release:Protocol.S_FIRE.projectile)
  
  ::Protocol::ProjectileInfo* temp = _impl_.projectile_;
  _impl_.projectile_ = nullptr;
  return temp;
}
inline ::Protocol::ProjectileInfo* S_FIRE::_internal_mutable_projectile() {
  
  if (_impl_.projectile_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ProjectileInfo>(GetArenaForAllocation());
    _impl_.projectile_ = p;
  }
  return _impl_.projectile_;
}
inline ::Protocol::ProjectileInfo* S_FIRE::mutable_projectile() {
  ::Protocol::ProjectileInfo* _msg = _internal_mutable_projectile();
  // @@protoc_insertion_point(field_mutable:Protocol.S_FIRE.projectile)
  return _msg;
}
inline void S_FIRE::set_allocated_projectile(::Protocol::ProjectileInfo* projectile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectile_);
  }
  if (projectile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(projectile));
    if (message_arena != submessage_arena) {
      projectile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projectile, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.projectile_ = projectile;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_FIRE.projectile)
}

// -------------------------------------------------------------------

// C_HIT

// uint64 ownerId = 1;
inline void C_HIT::clear_ownerid() {
  _impl_.ownerid_ = uint64_t{0u};
}
inline uint64_t C_HIT::_internal_ownerid() const {
  return _impl_.ownerid_;
}
inline uint64_t C_HIT::ownerid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_HIT.ownerId)
  return _internal_ownerid();
}
inline void C_HIT::_internal_set_ownerid(uint64_t value) {
  
  _impl_.ownerid_ = value;
}
inline void C_HIT::set_ownerid(uint64_t value) {
  _internal_set_ownerid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_HIT.ownerId)
}

// uint64 targetId = 2;
inline void C_HIT::clear_targetid() {
  _impl_.targetid_ = uint64_t{0u};
}
inline uint64_t C_HIT::_internal_targetid() const {
  return _impl_.targetid_;
}
inline uint64_t C_HIT::targetid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_HIT.targetId)
  return _internal_targetid();
}
inline void C_HIT::_internal_set_targetid(uint64_t value) {
  
  _impl_.targetid_ = value;
}
inline void C_HIT::set_targetid(uint64_t value) {
  _internal_set_targetid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_HIT.targetId)
}

// float damage = 3;
inline void C_HIT::clear_damage() {
  _impl_.damage_ = 0;
}
inline float C_HIT::_internal_damage() const {
  return _impl_.damage_;
}
inline float C_HIT::damage() const {
  // @@protoc_insertion_point(field_get:Protocol.C_HIT.damage)
  return _internal_damage();
}
inline void C_HIT::_internal_set_damage(float value) {
  
  _impl_.damage_ = value;
}
inline void C_HIT::set_damage(float value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:Protocol.C_HIT.damage)
}

// -------------------------------------------------------------------

// S_HIT

// uint64 ownerId = 1;
inline void S_HIT::clear_ownerid() {
  _impl_.ownerid_ = uint64_t{0u};
}
inline uint64_t S_HIT::_internal_ownerid() const {
  return _impl_.ownerid_;
}
inline uint64_t S_HIT::ownerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_HIT.ownerId)
  return _internal_ownerid();
}
inline void S_HIT::_internal_set_ownerid(uint64_t value) {
  
  _impl_.ownerid_ = value;
}
inline void S_HIT::set_ownerid(uint64_t value) {
  _internal_set_ownerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_HIT.ownerId)
}

// uint64 targetId = 2;
inline void S_HIT::clear_targetid() {
  _impl_.targetid_ = uint64_t{0u};
}
inline uint64_t S_HIT::_internal_targetid() const {
  return _impl_.targetid_;
}
inline uint64_t S_HIT::targetid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_HIT.targetId)
  return _internal_targetid();
}
inline void S_HIT::_internal_set_targetid(uint64_t value) {
  
  _impl_.targetid_ = value;
}
inline void S_HIT::set_targetid(uint64_t value) {
  _internal_set_targetid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_HIT.targetId)
}

// float damage = 3;
inline void S_HIT::clear_damage() {
  _impl_.damage_ = 0;
}
inline float S_HIT::_internal_damage() const {
  return _impl_.damage_;
}
inline float S_HIT::damage() const {
  // @@protoc_insertion_point(field_get:Protocol.S_HIT.damage)
  return _internal_damage();
}
inline void S_HIT::_internal_set_damage(float value) {
  
  _impl_.damage_ = value;
}
inline void S_HIT::set_damage(float value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:Protocol.S_HIT.damage)
}

// -------------------------------------------------------------------

// S_EXPUP

// uint64 ownerId = 1;
inline void S_EXPUP::clear_ownerid() {
  _impl_.ownerid_ = uint64_t{0u};
}
inline uint64_t S_EXPUP::_internal_ownerid() const {
  return _impl_.ownerid_;
}
inline uint64_t S_EXPUP::ownerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EXPUP.ownerId)
  return _internal_ownerid();
}
inline void S_EXPUP::_internal_set_ownerid(uint64_t value) {
  
  _impl_.ownerid_ = value;
}
inline void S_EXPUP::set_ownerid(uint64_t value) {
  _internal_set_ownerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EXPUP.ownerId)
}

// float exp = 2;
inline void S_EXPUP::clear_exp() {
  _impl_.exp_ = 0;
}
inline float S_EXPUP::_internal_exp() const {
  return _impl_.exp_;
}
inline float S_EXPUP::exp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EXPUP.exp)
  return _internal_exp();
}
inline void S_EXPUP::_internal_set_exp(float value) {
  
  _impl_.exp_ = value;
}
inline void S_EXPUP::set_exp(float value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EXPUP.exp)
}

// -------------------------------------------------------------------

// C_EXPUP

// uint64 ownerId = 1;
inline void C_EXPUP::clear_ownerid() {
  _impl_.ownerid_ = uint64_t{0u};
}
inline uint64_t C_EXPUP::_internal_ownerid() const {
  return _impl_.ownerid_;
}
inline uint64_t C_EXPUP::ownerid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EXPUP.ownerId)
  return _internal_ownerid();
}
inline void C_EXPUP::_internal_set_ownerid(uint64_t value) {
  
  _impl_.ownerid_ = value;
}
inline void C_EXPUP::set_ownerid(uint64_t value) {
  _internal_set_ownerid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EXPUP.ownerId)
}

// float exp = 2;
inline void C_EXPUP::clear_exp() {
  _impl_.exp_ = 0;
}
inline float C_EXPUP::_internal_exp() const {
  return _impl_.exp_;
}
inline float C_EXPUP::exp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EXPUP.exp)
  return _internal_exp();
}
inline void C_EXPUP::_internal_set_exp(float value) {
  
  _impl_.exp_ = value;
}
inline void C_EXPUP::set_exp(float value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EXPUP.exp)
}

// -------------------------------------------------------------------

// S_LVUP

// uint64 ownerId = 1;
inline void S_LVUP::clear_ownerid() {
  _impl_.ownerid_ = uint64_t{0u};
}
inline uint64_t S_LVUP::_internal_ownerid() const {
  return _impl_.ownerid_;
}
inline uint64_t S_LVUP::ownerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LVUP.ownerId)
  return _internal_ownerid();
}
inline void S_LVUP::_internal_set_ownerid(uint64_t value) {
  
  _impl_.ownerid_ = value;
}
inline void S_LVUP::set_ownerid(uint64_t value) {
  _internal_set_ownerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LVUP.ownerId)
}

// float currExp = 2;
inline void S_LVUP::clear_currexp() {
  _impl_.currexp_ = 0;
}
inline float S_LVUP::_internal_currexp() const {
  return _impl_.currexp_;
}
inline float S_LVUP::currexp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LVUP.currExp)
  return _internal_currexp();
}
inline void S_LVUP::_internal_set_currexp(float value) {
  
  _impl_.currexp_ = value;
}
inline void S_LVUP::set_currexp(float value) {
  _internal_set_currexp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LVUP.currExp)
}

// int64 level = 3;
inline void S_LVUP::clear_level() {
  _impl_.level_ = int64_t{0};
}
inline int64_t S_LVUP::_internal_level() const {
  return _impl_.level_;
}
inline int64_t S_LVUP::level() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LVUP.level)
  return _internal_level();
}
inline void S_LVUP::_internal_set_level(int64_t value) {
  
  _impl_.level_ = value;
}
inline void S_LVUP::set_level(int64_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LVUP.level)
}

// -------------------------------------------------------------------

// C_LVUP

// uint64 ownerId = 1;
inline void C_LVUP::clear_ownerid() {
  _impl_.ownerid_ = uint64_t{0u};
}
inline uint64_t C_LVUP::_internal_ownerid() const {
  return _impl_.ownerid_;
}
inline uint64_t C_LVUP::ownerid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LVUP.ownerId)
  return _internal_ownerid();
}
inline void C_LVUP::_internal_set_ownerid(uint64_t value) {
  
  _impl_.ownerid_ = value;
}
inline void C_LVUP::set_ownerid(uint64_t value) {
  _internal_set_ownerid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_LVUP.ownerId)
}

// float currExp = 2;
inline void C_LVUP::clear_currexp() {
  _impl_.currexp_ = 0;
}
inline float C_LVUP::_internal_currexp() const {
  return _impl_.currexp_;
}
inline float C_LVUP::currexp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LVUP.currExp)
  return _internal_currexp();
}
inline void C_LVUP::_internal_set_currexp(float value) {
  
  _impl_.currexp_ = value;
}
inline void C_LVUP::set_currexp(float value) {
  _internal_set_currexp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_LVUP.currExp)
}

// int64 level = 3;
inline void C_LVUP::clear_level() {
  _impl_.level_ = int64_t{0};
}
inline int64_t C_LVUP::_internal_level() const {
  return _impl_.level_;
}
inline int64_t C_LVUP::level() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LVUP.level)
  return _internal_level();
}
inline void C_LVUP::_internal_set_level(int64_t value) {
  
  _impl_.level_ = value;
}
inline void C_LVUP::set_level(int64_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.C_LVUP.level)
}

// -------------------------------------------------------------------

// C_AISPAWN_RANDOM

// uint64 object_id = 1;
inline void C_AISPAWN_RANDOM::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_AISPAWN_RANDOM::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_AISPAWN_RANDOM::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AISPAWN_RANDOM.object_id)
  return _internal_object_id();
}
inline void C_AISPAWN_RANDOM::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_AISPAWN_RANDOM::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AISPAWN_RANDOM.object_id)
}

// uint64 container_Idx = 2;
inline void C_AISPAWN_RANDOM::clear_container_idx() {
  _impl_.container_idx_ = uint64_t{0u};
}
inline uint64_t C_AISPAWN_RANDOM::_internal_container_idx() const {
  return _impl_.container_idx_;
}
inline uint64_t C_AISPAWN_RANDOM::container_idx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AISPAWN_RANDOM.container_Idx)
  return _internal_container_idx();
}
inline void C_AISPAWN_RANDOM::_internal_set_container_idx(uint64_t value) {
  
  _impl_.container_idx_ = value;
}
inline void C_AISPAWN_RANDOM::set_container_idx(uint64_t value) {
  _internal_set_container_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AISPAWN_RANDOM.container_Idx)
}

// -------------------------------------------------------------------

// S_AISPAWN_RANDOM

// uint64 object_id = 1;
inline void S_AISPAWN_RANDOM::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_AISPAWN_RANDOM::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_AISPAWN_RANDOM::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AISPAWN_RANDOM.object_id)
  return _internal_object_id();
}
inline void S_AISPAWN_RANDOM::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_AISPAWN_RANDOM::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AISPAWN_RANDOM.object_id)
}

// uint64 container_Idx = 2;
inline void S_AISPAWN_RANDOM::clear_container_idx() {
  _impl_.container_idx_ = uint64_t{0u};
}
inline uint64_t S_AISPAWN_RANDOM::_internal_container_idx() const {
  return _impl_.container_idx_;
}
inline uint64_t S_AISPAWN_RANDOM::container_idx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AISPAWN_RANDOM.container_Idx)
  return _internal_container_idx();
}
inline void S_AISPAWN_RANDOM::_internal_set_container_idx(uint64_t value) {
  
  _impl_.container_idx_ = value;
}
inline void S_AISPAWN_RANDOM::set_container_idx(uint64_t value) {
  _internal_set_container_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AISPAWN_RANDOM.container_Idx)
}

// -------------------------------------------------------------------

// C_AISPAWN_PATROL

// uint64 object_id = 1;
inline void C_AISPAWN_PATROL::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_AISPAWN_PATROL::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_AISPAWN_PATROL::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AISPAWN_PATROL.object_id)
  return _internal_object_id();
}
inline void C_AISPAWN_PATROL::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_AISPAWN_PATROL::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AISPAWN_PATROL.object_id)
}

// uint64 container_Idx = 2;
inline void C_AISPAWN_PATROL::clear_container_idx() {
  _impl_.container_idx_ = uint64_t{0u};
}
inline uint64_t C_AISPAWN_PATROL::_internal_container_idx() const {
  return _impl_.container_idx_;
}
inline uint64_t C_AISPAWN_PATROL::container_idx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AISPAWN_PATROL.container_Idx)
  return _internal_container_idx();
}
inline void C_AISPAWN_PATROL::_internal_set_container_idx(uint64_t value) {
  
  _impl_.container_idx_ = value;
}
inline void C_AISPAWN_PATROL::set_container_idx(uint64_t value) {
  _internal_set_container_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AISPAWN_PATROL.container_Idx)
}

// uint64 pointIdx = 3;
inline void C_AISPAWN_PATROL::clear_pointidx() {
  _impl_.pointidx_ = uint64_t{0u};
}
inline uint64_t C_AISPAWN_PATROL::_internal_pointidx() const {
  return _impl_.pointidx_;
}
inline uint64_t C_AISPAWN_PATROL::pointidx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AISPAWN_PATROL.pointIdx)
  return _internal_pointidx();
}
inline void C_AISPAWN_PATROL::_internal_set_pointidx(uint64_t value) {
  
  _impl_.pointidx_ = value;
}
inline void C_AISPAWN_PATROL::set_pointidx(uint64_t value) {
  _internal_set_pointidx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AISPAWN_PATROL.pointIdx)
}

// -------------------------------------------------------------------

// S_AISPAWN_PATROL

// uint64 object_id = 1;
inline void S_AISPAWN_PATROL::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_AISPAWN_PATROL::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_AISPAWN_PATROL::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AISPAWN_PATROL.object_id)
  return _internal_object_id();
}
inline void S_AISPAWN_PATROL::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_AISPAWN_PATROL::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AISPAWN_PATROL.object_id)
}

// uint64 container_Idx = 2;
inline void S_AISPAWN_PATROL::clear_container_idx() {
  _impl_.container_idx_ = uint64_t{0u};
}
inline uint64_t S_AISPAWN_PATROL::_internal_container_idx() const {
  return _impl_.container_idx_;
}
inline uint64_t S_AISPAWN_PATROL::container_idx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AISPAWN_PATROL.container_Idx)
  return _internal_container_idx();
}
inline void S_AISPAWN_PATROL::_internal_set_container_idx(uint64_t value) {
  
  _impl_.container_idx_ = value;
}
inline void S_AISPAWN_PATROL::set_container_idx(uint64_t value) {
  _internal_set_container_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AISPAWN_PATROL.container_Idx)
}

// uint64 pointIdx = 3;
inline void S_AISPAWN_PATROL::clear_pointidx() {
  _impl_.pointidx_ = uint64_t{0u};
}
inline uint64_t S_AISPAWN_PATROL::_internal_pointidx() const {
  return _impl_.pointidx_;
}
inline uint64_t S_AISPAWN_PATROL::pointidx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AISPAWN_PATROL.pointIdx)
  return _internal_pointidx();
}
inline void S_AISPAWN_PATROL::_internal_set_pointidx(uint64_t value) {
  
  _impl_.pointidx_ = value;
}
inline void S_AISPAWN_PATROL::set_pointidx(uint64_t value) {
  _internal_set_pointidx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AISPAWN_PATROL.pointIdx)
}

// -------------------------------------------------------------------

// C_AISPAWN_BOSS

// uint64 object_id = 1;
inline void C_AISPAWN_BOSS::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_AISPAWN_BOSS::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_AISPAWN_BOSS::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AISPAWN_BOSS.object_id)
  return _internal_object_id();
}
inline void C_AISPAWN_BOSS::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_AISPAWN_BOSS::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AISPAWN_BOSS.object_id)
}

// uint64 container_Idx = 2;
inline void C_AISPAWN_BOSS::clear_container_idx() {
  _impl_.container_idx_ = uint64_t{0u};
}
inline uint64_t C_AISPAWN_BOSS::_internal_container_idx() const {
  return _impl_.container_idx_;
}
inline uint64_t C_AISPAWN_BOSS::container_idx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AISPAWN_BOSS.container_Idx)
  return _internal_container_idx();
}
inline void C_AISPAWN_BOSS::_internal_set_container_idx(uint64_t value) {
  
  _impl_.container_idx_ = value;
}
inline void C_AISPAWN_BOSS::set_container_idx(uint64_t value) {
  _internal_set_container_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AISPAWN_BOSS.container_Idx)
}

// -------------------------------------------------------------------

// S_AISPAWN_BOSS

// uint64 object_id = 1;
inline void S_AISPAWN_BOSS::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_AISPAWN_BOSS::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_AISPAWN_BOSS::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AISPAWN_BOSS.object_id)
  return _internal_object_id();
}
inline void S_AISPAWN_BOSS::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_AISPAWN_BOSS::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AISPAWN_BOSS.object_id)
}

// uint64 container_Idx = 2;
inline void S_AISPAWN_BOSS::clear_container_idx() {
  _impl_.container_idx_ = uint64_t{0u};
}
inline uint64_t S_AISPAWN_BOSS::_internal_container_idx() const {
  return _impl_.container_idx_;
}
inline uint64_t S_AISPAWN_BOSS::container_idx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AISPAWN_BOSS.container_Idx)
  return _internal_container_idx();
}
inline void S_AISPAWN_BOSS::_internal_set_container_idx(uint64_t value) {
  
  _impl_.container_idx_ = value;
}
inline void S_AISPAWN_BOSS::set_container_idx(uint64_t value) {
  _internal_set_container_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AISPAWN_BOSS.container_Idx)
}

// -------------------------------------------------------------------

// S_AIMOVE

// .Protocol.PosInfo info = 1;
inline bool S_AIMOVE::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_AIMOVE::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::PosInfo& S_AIMOVE::_internal_info() const {
  const ::Protocol::PosInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& S_AIMOVE::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIMOVE.info)
  return _internal_info();
}
inline void S_AIMOVE::unsafe_arena_set_allocated_info(
    ::Protocol::PosInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_AIMOVE.info)
}
inline ::Protocol::PosInfo* S_AIMOVE::release_info() {
  
  ::Protocol::PosInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* S_AIMOVE::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_AIMOVE.info)
  
  ::Protocol::PosInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* S_AIMOVE::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::PosInfo* S_AIMOVE::mutable_info() {
  ::Protocol::PosInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_AIMOVE.info)
  return _msg;
}
inline void S_AIMOVE::set_allocated_info(::Protocol::PosInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_AIMOVE.info)
}

// -------------------------------------------------------------------

// C_AIMOVE

// .Protocol.PosInfo info = 1;
inline bool C_AIMOVE::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool C_AIMOVE::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::PosInfo& C_AIMOVE::_internal_info() const {
  const ::Protocol::PosInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PosInfo&>(
      ::Protocol::_PosInfo_default_instance_);
}
inline const ::Protocol::PosInfo& C_AIMOVE::info() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIMOVE.info)
  return _internal_info();
}
inline void C_AIMOVE::unsafe_arena_set_allocated_info(
    ::Protocol::PosInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_AIMOVE.info)
}
inline ::Protocol::PosInfo* C_AIMOVE::release_info() {
  
  ::Protocol::PosInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PosInfo* C_AIMOVE::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.C_AIMOVE.info)
  
  ::Protocol::PosInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::PosInfo* C_AIMOVE::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PosInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::PosInfo* C_AIMOVE::mutable_info() {
  ::Protocol::PosInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.C_AIMOVE.info)
  return _msg;
}
inline void C_AIMOVE::set_allocated_info(::Protocol::PosInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_AIMOVE.info)
}

// -------------------------------------------------------------------

// S_AIMOVESTOP

// uint64 object_id = 1;
inline void S_AIMOVESTOP::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_AIMOVESTOP::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_AIMOVESTOP::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIMOVESTOP.object_id)
  return _internal_object_id();
}
inline void S_AIMOVESTOP::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_AIMOVESTOP::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIMOVESTOP.object_id)
}

// float speed = 2;
inline void S_AIMOVESTOP::clear_speed() {
  _impl_.speed_ = 0;
}
inline float S_AIMOVESTOP::_internal_speed() const {
  return _impl_.speed_;
}
inline float S_AIMOVESTOP::speed() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIMOVESTOP.speed)
  return _internal_speed();
}
inline void S_AIMOVESTOP::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void S_AIMOVESTOP::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIMOVESTOP.speed)
}

// -------------------------------------------------------------------

// C_AIMOVESTOP

// uint64 object_id = 1;
inline void C_AIMOVESTOP::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_AIMOVESTOP::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_AIMOVESTOP::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIMOVESTOP.object_id)
  return _internal_object_id();
}
inline void C_AIMOVESTOP::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_AIMOVESTOP::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIMOVESTOP.object_id)
}

// float speed = 2;
inline void C_AIMOVESTOP::clear_speed() {
  _impl_.speed_ = 0;
}
inline float C_AIMOVESTOP::_internal_speed() const {
  return _impl_.speed_;
}
inline float C_AIMOVESTOP::speed() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIMOVESTOP.speed)
  return _internal_speed();
}
inline void C_AIMOVESTOP::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void C_AIMOVESTOP::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIMOVESTOP.speed)
}

// -------------------------------------------------------------------

// S_AIATTACK

// uint64 object_id = 1;
inline void S_AIATTACK::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_AIATTACK::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_AIATTACK::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIATTACK.object_id)
  return _internal_object_id();
}
inline void S_AIATTACK::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_AIATTACK::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIATTACK.object_id)
}

// uint64 attack_idx = 2;
inline void S_AIATTACK::clear_attack_idx() {
  _impl_.attack_idx_ = uint64_t{0u};
}
inline uint64_t S_AIATTACK::_internal_attack_idx() const {
  return _impl_.attack_idx_;
}
inline uint64_t S_AIATTACK::attack_idx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIATTACK.attack_idx)
  return _internal_attack_idx();
}
inline void S_AIATTACK::_internal_set_attack_idx(uint64_t value) {
  
  _impl_.attack_idx_ = value;
}
inline void S_AIATTACK::set_attack_idx(uint64_t value) {
  _internal_set_attack_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIATTACK.attack_idx)
}

// -------------------------------------------------------------------

// C_AIATTACK

// uint64 object_id = 1;
inline void C_AIATTACK::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_AIATTACK::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_AIATTACK::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIATTACK.object_id)
  return _internal_object_id();
}
inline void C_AIATTACK::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_AIATTACK::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIATTACK.object_id)
}

// uint64 attack_idx = 2;
inline void C_AIATTACK::clear_attack_idx() {
  _impl_.attack_idx_ = uint64_t{0u};
}
inline uint64_t C_AIATTACK::_internal_attack_idx() const {
  return _impl_.attack_idx_;
}
inline uint64_t C_AIATTACK::attack_idx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIATTACK.attack_idx)
  return _internal_attack_idx();
}
inline void C_AIATTACK::_internal_set_attack_idx(uint64_t value) {
  
  _impl_.attack_idx_ = value;
}
inline void C_AIATTACK::set_attack_idx(uint64_t value) {
  _internal_set_attack_idx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIATTACK.attack_idx)
}

// -------------------------------------------------------------------

// S_AIATTACK_BOSS2

// uint64 object_id = 1;
inline void S_AIATTACK_BOSS2::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_AIATTACK_BOSS2::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_AIATTACK_BOSS2::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIATTACK_BOSS2.object_id)
  return _internal_object_id();
}
inline void S_AIATTACK_BOSS2::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_AIATTACK_BOSS2::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIATTACK_BOSS2.object_id)
}

// repeated uint64 target_id = 2;
inline int S_AIATTACK_BOSS2::_internal_target_id_size() const {
  return _impl_.target_id_.size();
}
inline int S_AIATTACK_BOSS2::target_id_size() const {
  return _internal_target_id_size();
}
inline void S_AIATTACK_BOSS2::clear_target_id() {
  _impl_.target_id_.Clear();
}
inline uint64_t S_AIATTACK_BOSS2::_internal_target_id(int index) const {
  return _impl_.target_id_.Get(index);
}
inline uint64_t S_AIATTACK_BOSS2::target_id(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIATTACK_BOSS2.target_id)
  return _internal_target_id(index);
}
inline void S_AIATTACK_BOSS2::set_target_id(int index, uint64_t value) {
  _impl_.target_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIATTACK_BOSS2.target_id)
}
inline void S_AIATTACK_BOSS2::_internal_add_target_id(uint64_t value) {
  _impl_.target_id_.Add(value);
}
inline void S_AIATTACK_BOSS2::add_target_id(uint64_t value) {
  _internal_add_target_id(value);
  // @@protoc_insertion_point(field_add:Protocol.S_AIATTACK_BOSS2.target_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_AIATTACK_BOSS2::_internal_target_id() const {
  return _impl_.target_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_AIATTACK_BOSS2::target_id() const {
  // @@protoc_insertion_point(field_list:Protocol.S_AIATTACK_BOSS2.target_id)
  return _internal_target_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_AIATTACK_BOSS2::_internal_mutable_target_id() {
  return &_impl_.target_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_AIATTACK_BOSS2::mutable_target_id() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_AIATTACK_BOSS2.target_id)
  return _internal_mutable_target_id();
}

// -------------------------------------------------------------------

// C_AIATTACK_BOSS2

// uint64 object_id = 1;
inline void C_AIATTACK_BOSS2::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_AIATTACK_BOSS2::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_AIATTACK_BOSS2::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIATTACK_BOSS2.object_id)
  return _internal_object_id();
}
inline void C_AIATTACK_BOSS2::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_AIATTACK_BOSS2::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIATTACK_BOSS2.object_id)
}

// repeated uint64 target_id = 2;
inline int C_AIATTACK_BOSS2::_internal_target_id_size() const {
  return _impl_.target_id_.size();
}
inline int C_AIATTACK_BOSS2::target_id_size() const {
  return _internal_target_id_size();
}
inline void C_AIATTACK_BOSS2::clear_target_id() {
  _impl_.target_id_.Clear();
}
inline uint64_t C_AIATTACK_BOSS2::_internal_target_id(int index) const {
  return _impl_.target_id_.Get(index);
}
inline uint64_t C_AIATTACK_BOSS2::target_id(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIATTACK_BOSS2.target_id)
  return _internal_target_id(index);
}
inline void C_AIATTACK_BOSS2::set_target_id(int index, uint64_t value) {
  _impl_.target_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIATTACK_BOSS2.target_id)
}
inline void C_AIATTACK_BOSS2::_internal_add_target_id(uint64_t value) {
  _impl_.target_id_.Add(value);
}
inline void C_AIATTACK_BOSS2::add_target_id(uint64_t value) {
  _internal_add_target_id(value);
  // @@protoc_insertion_point(field_add:Protocol.C_AIATTACK_BOSS2.target_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
C_AIATTACK_BOSS2::_internal_target_id() const {
  return _impl_.target_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
C_AIATTACK_BOSS2::target_id() const {
  // @@protoc_insertion_point(field_list:Protocol.C_AIATTACK_BOSS2.target_id)
  return _internal_target_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
C_AIATTACK_BOSS2::_internal_mutable_target_id() {
  return &_impl_.target_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
C_AIATTACK_BOSS2::mutable_target_id() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_AIATTACK_BOSS2.target_id)
  return _internal_mutable_target_id();
}

// -------------------------------------------------------------------

// S_AIROTATE

// uint64 object_id = 1;
inline void S_AIROTATE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_AIROTATE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_AIROTATE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIROTATE.object_id)
  return _internal_object_id();
}
inline void S_AIROTATE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_AIROTATE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIROTATE.object_id)
}

// float yaw = 2;
inline void S_AIROTATE::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float S_AIROTATE::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float S_AIROTATE::yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIROTATE.yaw)
  return _internal_yaw();
}
inline void S_AIROTATE::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void S_AIROTATE::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIROTATE.yaw)
}

// float pitch = 3;
inline void S_AIROTATE::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float S_AIROTATE::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float S_AIROTATE::pitch() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIROTATE.pitch)
  return _internal_pitch();
}
inline void S_AIROTATE::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void S_AIROTATE::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIROTATE.pitch)
}

// float roll = 4;
inline void S_AIROTATE::clear_roll() {
  _impl_.roll_ = 0;
}
inline float S_AIROTATE::_internal_roll() const {
  return _impl_.roll_;
}
inline float S_AIROTATE::roll() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIROTATE.roll)
  return _internal_roll();
}
inline void S_AIROTATE::_internal_set_roll(float value) {
  
  _impl_.roll_ = value;
}
inline void S_AIROTATE::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIROTATE.roll)
}

// float x = 5;
inline void S_AIROTATE::clear_x() {
  _impl_.x_ = 0;
}
inline float S_AIROTATE::_internal_x() const {
  return _impl_.x_;
}
inline float S_AIROTATE::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIROTATE.x)
  return _internal_x();
}
inline void S_AIROTATE::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void S_AIROTATE::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIROTATE.x)
}

// float y = 6;
inline void S_AIROTATE::clear_y() {
  _impl_.y_ = 0;
}
inline float S_AIROTATE::_internal_y() const {
  return _impl_.y_;
}
inline float S_AIROTATE::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIROTATE.y)
  return _internal_y();
}
inline void S_AIROTATE::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void S_AIROTATE::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIROTATE.y)
}

// float z = 7;
inline void S_AIROTATE::clear_z() {
  _impl_.z_ = 0;
}
inline float S_AIROTATE::_internal_z() const {
  return _impl_.z_;
}
inline float S_AIROTATE::z() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIROTATE.z)
  return _internal_z();
}
inline void S_AIROTATE::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void S_AIROTATE::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIROTATE.z)
}

// -------------------------------------------------------------------

// C_AIROTATE

// uint64 object_id = 1;
inline void C_AIROTATE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_AIROTATE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_AIROTATE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIROTATE.object_id)
  return _internal_object_id();
}
inline void C_AIROTATE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_AIROTATE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIROTATE.object_id)
}

// float yaw = 2;
inline void C_AIROTATE::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float C_AIROTATE::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float C_AIROTATE::yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIROTATE.yaw)
  return _internal_yaw();
}
inline void C_AIROTATE::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void C_AIROTATE::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIROTATE.yaw)
}

// float pitch = 3;
inline void C_AIROTATE::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float C_AIROTATE::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float C_AIROTATE::pitch() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIROTATE.pitch)
  return _internal_pitch();
}
inline void C_AIROTATE::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void C_AIROTATE::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIROTATE.pitch)
}

// float roll = 4;
inline void C_AIROTATE::clear_roll() {
  _impl_.roll_ = 0;
}
inline float C_AIROTATE::_internal_roll() const {
  return _impl_.roll_;
}
inline float C_AIROTATE::roll() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIROTATE.roll)
  return _internal_roll();
}
inline void C_AIROTATE::_internal_set_roll(float value) {
  
  _impl_.roll_ = value;
}
inline void C_AIROTATE::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIROTATE.roll)
}

// float x = 5;
inline void C_AIROTATE::clear_x() {
  _impl_.x_ = 0;
}
inline float C_AIROTATE::_internal_x() const {
  return _impl_.x_;
}
inline float C_AIROTATE::x() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIROTATE.x)
  return _internal_x();
}
inline void C_AIROTATE::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void C_AIROTATE::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIROTATE.x)
}

// float y = 6;
inline void C_AIROTATE::clear_y() {
  _impl_.y_ = 0;
}
inline float C_AIROTATE::_internal_y() const {
  return _impl_.y_;
}
inline float C_AIROTATE::y() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIROTATE.y)
  return _internal_y();
}
inline void C_AIROTATE::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void C_AIROTATE::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIROTATE.y)
}

// float z = 7;
inline void C_AIROTATE::clear_z() {
  _impl_.z_ = 0;
}
inline float C_AIROTATE::_internal_z() const {
  return _impl_.z_;
}
inline float C_AIROTATE::z() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIROTATE.z)
  return _internal_z();
}
inline void C_AIROTATE::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void C_AIROTATE::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIROTATE.z)
}

// -------------------------------------------------------------------

// S_AIHIT

// uint64 object_id = 1;
inline void S_AIHIT::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_AIHIT::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_AIHIT::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIHIT.object_id)
  return _internal_object_id();
}
inline void S_AIHIT::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_AIHIT::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIHIT.object_id)
}

// -------------------------------------------------------------------

// C_AIHIT

// uint64 object_id = 1;
inline void C_AIHIT::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_AIHIT::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_AIHIT::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIHIT.object_id)
  return _internal_object_id();
}
inline void C_AIHIT::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_AIHIT::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIHIT.object_id)
}

// -------------------------------------------------------------------

// S_DAMAGED

// uint64 object_id = 1;
inline void S_DAMAGED::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_DAMAGED::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_DAMAGED::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DAMAGED.object_id)
  return _internal_object_id();
}
inline void S_DAMAGED::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_DAMAGED::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DAMAGED.object_id)
}

// float hp = 2;
inline void S_DAMAGED::clear_hp() {
  _impl_.hp_ = 0;
}
inline float S_DAMAGED::_internal_hp() const {
  return _impl_.hp_;
}
inline float S_DAMAGED::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DAMAGED.hp)
  return _internal_hp();
}
inline void S_DAMAGED::_internal_set_hp(float value) {
  
  _impl_.hp_ = value;
}
inline void S_DAMAGED::set_hp(float value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DAMAGED.hp)
}

// float guardPoint = 3;
inline void S_DAMAGED::clear_guardpoint() {
  _impl_.guardpoint_ = 0;
}
inline float S_DAMAGED::_internal_guardpoint() const {
  return _impl_.guardpoint_;
}
inline float S_DAMAGED::guardpoint() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DAMAGED.guardPoint)
  return _internal_guardpoint();
}
inline void S_DAMAGED::_internal_set_guardpoint(float value) {
  
  _impl_.guardpoint_ = value;
}
inline void S_DAMAGED::set_guardpoint(float value) {
  _internal_set_guardpoint(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DAMAGED.guardPoint)
}

// -------------------------------------------------------------------

// C_DAMAGED

// uint64 object_id = 1;
inline void C_DAMAGED::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_DAMAGED::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_DAMAGED::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_DAMAGED.object_id)
  return _internal_object_id();
}
inline void C_DAMAGED::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_DAMAGED::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_DAMAGED.object_id)
}

// float hp = 2;
inline void C_DAMAGED::clear_hp() {
  _impl_.hp_ = 0;
}
inline float C_DAMAGED::_internal_hp() const {
  return _impl_.hp_;
}
inline float C_DAMAGED::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_DAMAGED.hp)
  return _internal_hp();
}
inline void C_DAMAGED::_internal_set_hp(float value) {
  
  _impl_.hp_ = value;
}
inline void C_DAMAGED::set_hp(float value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_DAMAGED.hp)
}

// float guardPoint = 3;
inline void C_DAMAGED::clear_guardpoint() {
  _impl_.guardpoint_ = 0;
}
inline float C_DAMAGED::_internal_guardpoint() const {
  return _impl_.guardpoint_;
}
inline float C_DAMAGED::guardpoint() const {
  // @@protoc_insertion_point(field_get:Protocol.C_DAMAGED.guardPoint)
  return _internal_guardpoint();
}
inline void C_DAMAGED::_internal_set_guardpoint(float value) {
  
  _impl_.guardpoint_ = value;
}
inline void C_DAMAGED::set_guardpoint(float value) {
  _internal_set_guardpoint(value);
  // @@protoc_insertion_point(field_set:Protocol.C_DAMAGED.guardPoint)
}

// -------------------------------------------------------------------

// S_AIDAMAGED

// uint64 object_id = 1;
inline void S_AIDAMAGED::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_AIDAMAGED::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_AIDAMAGED::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIDAMAGED.object_id)
  return _internal_object_id();
}
inline void S_AIDAMAGED::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_AIDAMAGED::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIDAMAGED.object_id)
}

// float hp = 2;
inline void S_AIDAMAGED::clear_hp() {
  _impl_.hp_ = 0;
}
inline float S_AIDAMAGED::_internal_hp() const {
  return _impl_.hp_;
}
inline float S_AIDAMAGED::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIDAMAGED.hp)
  return _internal_hp();
}
inline void S_AIDAMAGED::_internal_set_hp(float value) {
  
  _impl_.hp_ = value;
}
inline void S_AIDAMAGED::set_hp(float value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIDAMAGED.hp)
}

// -------------------------------------------------------------------

// C_AIDAMAGED

// uint64 object_id = 1;
inline void C_AIDAMAGED::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_AIDAMAGED::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_AIDAMAGED::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIDAMAGED.object_id)
  return _internal_object_id();
}
inline void C_AIDAMAGED::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_AIDAMAGED::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIDAMAGED.object_id)
}

// float hp = 2;
inline void C_AIDAMAGED::clear_hp() {
  _impl_.hp_ = 0;
}
inline float C_AIDAMAGED::_internal_hp() const {
  return _impl_.hp_;
}
inline float C_AIDAMAGED::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIDAMAGED.hp)
  return _internal_hp();
}
inline void C_AIDAMAGED::_internal_set_hp(float value) {
  
  _impl_.hp_ = value;
}
inline void C_AIDAMAGED::set_hp(float value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIDAMAGED.hp)
}

// -------------------------------------------------------------------

// S_AIDEAD

// uint64 object_id = 1;
inline void S_AIDEAD::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_AIDEAD::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_AIDEAD::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIDEAD.object_id)
  return _internal_object_id();
}
inline void S_AIDEAD::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_AIDEAD::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIDEAD.object_id)
}

// bool dead = 2;
inline void S_AIDEAD::clear_dead() {
  _impl_.dead_ = false;
}
inline bool S_AIDEAD::_internal_dead() const {
  return _impl_.dead_;
}
inline bool S_AIDEAD::dead() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIDEAD.dead)
  return _internal_dead();
}
inline void S_AIDEAD::_internal_set_dead(bool value) {
  
  _impl_.dead_ = value;
}
inline void S_AIDEAD::set_dead(bool value) {
  _internal_set_dead(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIDEAD.dead)
}

// uint64 owner_object_id = 3;
inline void S_AIDEAD::clear_owner_object_id() {
  _impl_.owner_object_id_ = uint64_t{0u};
}
inline uint64_t S_AIDEAD::_internal_owner_object_id() const {
  return _impl_.owner_object_id_;
}
inline uint64_t S_AIDEAD::owner_object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIDEAD.owner_object_id)
  return _internal_owner_object_id();
}
inline void S_AIDEAD::_internal_set_owner_object_id(uint64_t value) {
  
  _impl_.owner_object_id_ = value;
}
inline void S_AIDEAD::set_owner_object_id(uint64_t value) {
  _internal_set_owner_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIDEAD.owner_object_id)
}

// float exp = 4;
inline void S_AIDEAD::clear_exp() {
  _impl_.exp_ = 0;
}
inline float S_AIDEAD::_internal_exp() const {
  return _impl_.exp_;
}
inline float S_AIDEAD::exp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIDEAD.exp)
  return _internal_exp();
}
inline void S_AIDEAD::_internal_set_exp(float value) {
  
  _impl_.exp_ = value;
}
inline void S_AIDEAD::set_exp(float value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIDEAD.exp)
}

// -------------------------------------------------------------------

// C_AIDEAD

// uint64 object_id = 1;
inline void C_AIDEAD::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_AIDEAD::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_AIDEAD::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIDEAD.object_id)
  return _internal_object_id();
}
inline void C_AIDEAD::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_AIDEAD::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIDEAD.object_id)
}

// bool dead = 2;
inline void C_AIDEAD::clear_dead() {
  _impl_.dead_ = false;
}
inline bool C_AIDEAD::_internal_dead() const {
  return _impl_.dead_;
}
inline bool C_AIDEAD::dead() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIDEAD.dead)
  return _internal_dead();
}
inline void C_AIDEAD::_internal_set_dead(bool value) {
  
  _impl_.dead_ = value;
}
inline void C_AIDEAD::set_dead(bool value) {
  _internal_set_dead(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIDEAD.dead)
}

// uint64 owner_object_id = 3;
inline void C_AIDEAD::clear_owner_object_id() {
  _impl_.owner_object_id_ = uint64_t{0u};
}
inline uint64_t C_AIDEAD::_internal_owner_object_id() const {
  return _impl_.owner_object_id_;
}
inline uint64_t C_AIDEAD::owner_object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIDEAD.owner_object_id)
  return _internal_owner_object_id();
}
inline void C_AIDEAD::_internal_set_owner_object_id(uint64_t value) {
  
  _impl_.owner_object_id_ = value;
}
inline void C_AIDEAD::set_owner_object_id(uint64_t value) {
  _internal_set_owner_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIDEAD.owner_object_id)
}

// float exp = 4;
inline void C_AIDEAD::clear_exp() {
  _impl_.exp_ = 0;
}
inline float C_AIDEAD::_internal_exp() const {
  return _impl_.exp_;
}
inline float C_AIDEAD::exp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIDEAD.exp)
  return _internal_exp();
}
inline void C_AIDEAD::_internal_set_exp(float value) {
  
  _impl_.exp_ = value;
}
inline void C_AIDEAD::set_exp(float value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIDEAD.exp)
}

// -------------------------------------------------------------------

// S_PLAYERDEAD

// uint64 object_id = 1;
inline void S_PLAYERDEAD::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_PLAYERDEAD::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_PLAYERDEAD::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERDEAD.object_id)
  return _internal_object_id();
}
inline void S_PLAYERDEAD::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_PLAYERDEAD::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERDEAD.object_id)
}

// bool dead = 2;
inline void S_PLAYERDEAD::clear_dead() {
  _impl_.dead_ = false;
}
inline bool S_PLAYERDEAD::_internal_dead() const {
  return _impl_.dead_;
}
inline bool S_PLAYERDEAD::dead() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERDEAD.dead)
  return _internal_dead();
}
inline void S_PLAYERDEAD::_internal_set_dead(bool value) {
  
  _impl_.dead_ = value;
}
inline void S_PLAYERDEAD::set_dead(bool value) {
  _internal_set_dead(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERDEAD.dead)
}

// -------------------------------------------------------------------

// C_PLAYERDEAD

// uint64 object_id = 1;
inline void C_PLAYERDEAD::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_PLAYERDEAD::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_PLAYERDEAD::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERDEAD.object_id)
  return _internal_object_id();
}
inline void C_PLAYERDEAD::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_PLAYERDEAD::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERDEAD.object_id)
}

// bool dead = 2;
inline void C_PLAYERDEAD::clear_dead() {
  _impl_.dead_ = false;
}
inline bool C_PLAYERDEAD::_internal_dead() const {
  return _impl_.dead_;
}
inline bool C_PLAYERDEAD::dead() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERDEAD.dead)
  return _internal_dead();
}
inline void C_PLAYERDEAD::_internal_set_dead(bool value) {
  
  _impl_.dead_ = value;
}
inline void C_PLAYERDEAD::set_dead(bool value) {
  _internal_set_dead(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERDEAD.dead)
}

// -------------------------------------------------------------------

// S_AIPROJSPAWN

// uint64 object_id = 1;
inline void S_AIPROJSPAWN::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_AIPROJSPAWN::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_AIPROJSPAWN::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIPROJSPAWN.object_id)
  return _internal_object_id();
}
inline void S_AIPROJSPAWN::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_AIPROJSPAWN::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIPROJSPAWN.object_id)
}

// int64 ProjIdx = 2;
inline void S_AIPROJSPAWN::clear_projidx() {
  _impl_.projidx_ = int64_t{0};
}
inline int64_t S_AIPROJSPAWN::_internal_projidx() const {
  return _impl_.projidx_;
}
inline int64_t S_AIPROJSPAWN::projidx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIPROJSPAWN.ProjIdx)
  return _internal_projidx();
}
inline void S_AIPROJSPAWN::_internal_set_projidx(int64_t value) {
  
  _impl_.projidx_ = value;
}
inline void S_AIPROJSPAWN::set_projidx(int64_t value) {
  _internal_set_projidx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIPROJSPAWN.ProjIdx)
}

// float x = 3;
inline void S_AIPROJSPAWN::clear_x() {
  _impl_.x_ = 0;
}
inline float S_AIPROJSPAWN::_internal_x() const {
  return _impl_.x_;
}
inline float S_AIPROJSPAWN::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIPROJSPAWN.x)
  return _internal_x();
}
inline void S_AIPROJSPAWN::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void S_AIPROJSPAWN::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIPROJSPAWN.x)
}

// float y = 4;
inline void S_AIPROJSPAWN::clear_y() {
  _impl_.y_ = 0;
}
inline float S_AIPROJSPAWN::_internal_y() const {
  return _impl_.y_;
}
inline float S_AIPROJSPAWN::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIPROJSPAWN.y)
  return _internal_y();
}
inline void S_AIPROJSPAWN::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void S_AIPROJSPAWN::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIPROJSPAWN.y)
}

// float z = 5;
inline void S_AIPROJSPAWN::clear_z() {
  _impl_.z_ = 0;
}
inline float S_AIPROJSPAWN::_internal_z() const {
  return _impl_.z_;
}
inline float S_AIPROJSPAWN::z() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIPROJSPAWN.z)
  return _internal_z();
}
inline void S_AIPROJSPAWN::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void S_AIPROJSPAWN::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIPROJSPAWN.z)
}

// float yaw = 6;
inline void S_AIPROJSPAWN::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float S_AIPROJSPAWN::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float S_AIPROJSPAWN::yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIPROJSPAWN.yaw)
  return _internal_yaw();
}
inline void S_AIPROJSPAWN::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void S_AIPROJSPAWN::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIPROJSPAWN.yaw)
}

// float pitch = 7;
inline void S_AIPROJSPAWN::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float S_AIPROJSPAWN::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float S_AIPROJSPAWN::pitch() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIPROJSPAWN.pitch)
  return _internal_pitch();
}
inline void S_AIPROJSPAWN::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void S_AIPROJSPAWN::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIPROJSPAWN.pitch)
}

// float roll = 8;
inline void S_AIPROJSPAWN::clear_roll() {
  _impl_.roll_ = 0;
}
inline float S_AIPROJSPAWN::_internal_roll() const {
  return _impl_.roll_;
}
inline float S_AIPROJSPAWN::roll() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIPROJSPAWN.roll)
  return _internal_roll();
}
inline void S_AIPROJSPAWN::_internal_set_roll(float value) {
  
  _impl_.roll_ = value;
}
inline void S_AIPROJSPAWN::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIPROJSPAWN.roll)
}

// float speed = 9;
inline void S_AIPROJSPAWN::clear_speed() {
  _impl_.speed_ = 0;
}
inline float S_AIPROJSPAWN::_internal_speed() const {
  return _impl_.speed_;
}
inline float S_AIPROJSPAWN::speed() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIPROJSPAWN.speed)
  return _internal_speed();
}
inline void S_AIPROJSPAWN::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void S_AIPROJSPAWN::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIPROJSPAWN.speed)
}

// float attackDmg = 10;
inline void S_AIPROJSPAWN::clear_attackdmg() {
  _impl_.attackdmg_ = 0;
}
inline float S_AIPROJSPAWN::_internal_attackdmg() const {
  return _impl_.attackdmg_;
}
inline float S_AIPROJSPAWN::attackdmg() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AIPROJSPAWN.attackDmg)
  return _internal_attackdmg();
}
inline void S_AIPROJSPAWN::_internal_set_attackdmg(float value) {
  
  _impl_.attackdmg_ = value;
}
inline void S_AIPROJSPAWN::set_attackdmg(float value) {
  _internal_set_attackdmg(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AIPROJSPAWN.attackDmg)
}

// -------------------------------------------------------------------

// C_AIPROJSPAWN

// uint64 object_id = 1;
inline void C_AIPROJSPAWN::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_AIPROJSPAWN::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_AIPROJSPAWN::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIPROJSPAWN.object_id)
  return _internal_object_id();
}
inline void C_AIPROJSPAWN::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_AIPROJSPAWN::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIPROJSPAWN.object_id)
}

// int64 ProjIdx = 2;
inline void C_AIPROJSPAWN::clear_projidx() {
  _impl_.projidx_ = int64_t{0};
}
inline int64_t C_AIPROJSPAWN::_internal_projidx() const {
  return _impl_.projidx_;
}
inline int64_t C_AIPROJSPAWN::projidx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIPROJSPAWN.ProjIdx)
  return _internal_projidx();
}
inline void C_AIPROJSPAWN::_internal_set_projidx(int64_t value) {
  
  _impl_.projidx_ = value;
}
inline void C_AIPROJSPAWN::set_projidx(int64_t value) {
  _internal_set_projidx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIPROJSPAWN.ProjIdx)
}

// float x = 3;
inline void C_AIPROJSPAWN::clear_x() {
  _impl_.x_ = 0;
}
inline float C_AIPROJSPAWN::_internal_x() const {
  return _impl_.x_;
}
inline float C_AIPROJSPAWN::x() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIPROJSPAWN.x)
  return _internal_x();
}
inline void C_AIPROJSPAWN::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void C_AIPROJSPAWN::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIPROJSPAWN.x)
}

// float y = 4;
inline void C_AIPROJSPAWN::clear_y() {
  _impl_.y_ = 0;
}
inline float C_AIPROJSPAWN::_internal_y() const {
  return _impl_.y_;
}
inline float C_AIPROJSPAWN::y() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIPROJSPAWN.y)
  return _internal_y();
}
inline void C_AIPROJSPAWN::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void C_AIPROJSPAWN::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIPROJSPAWN.y)
}

// float z = 5;
inline void C_AIPROJSPAWN::clear_z() {
  _impl_.z_ = 0;
}
inline float C_AIPROJSPAWN::_internal_z() const {
  return _impl_.z_;
}
inline float C_AIPROJSPAWN::z() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIPROJSPAWN.z)
  return _internal_z();
}
inline void C_AIPROJSPAWN::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void C_AIPROJSPAWN::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIPROJSPAWN.z)
}

// float yaw = 6;
inline void C_AIPROJSPAWN::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float C_AIPROJSPAWN::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float C_AIPROJSPAWN::yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIPROJSPAWN.yaw)
  return _internal_yaw();
}
inline void C_AIPROJSPAWN::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void C_AIPROJSPAWN::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIPROJSPAWN.yaw)
}

// float pitch = 7;
inline void C_AIPROJSPAWN::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float C_AIPROJSPAWN::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float C_AIPROJSPAWN::pitch() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIPROJSPAWN.pitch)
  return _internal_pitch();
}
inline void C_AIPROJSPAWN::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void C_AIPROJSPAWN::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIPROJSPAWN.pitch)
}

// float roll = 8;
inline void C_AIPROJSPAWN::clear_roll() {
  _impl_.roll_ = 0;
}
inline float C_AIPROJSPAWN::_internal_roll() const {
  return _impl_.roll_;
}
inline float C_AIPROJSPAWN::roll() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIPROJSPAWN.roll)
  return _internal_roll();
}
inline void C_AIPROJSPAWN::_internal_set_roll(float value) {
  
  _impl_.roll_ = value;
}
inline void C_AIPROJSPAWN::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIPROJSPAWN.roll)
}

// float speed = 9;
inline void C_AIPROJSPAWN::clear_speed() {
  _impl_.speed_ = 0;
}
inline float C_AIPROJSPAWN::_internal_speed() const {
  return _impl_.speed_;
}
inline float C_AIPROJSPAWN::speed() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIPROJSPAWN.speed)
  return _internal_speed();
}
inline void C_AIPROJSPAWN::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void C_AIPROJSPAWN::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIPROJSPAWN.speed)
}

// float attackDmg = 10;
inline void C_AIPROJSPAWN::clear_attackdmg() {
  _impl_.attackdmg_ = 0;
}
inline float C_AIPROJSPAWN::_internal_attackdmg() const {
  return _impl_.attackdmg_;
}
inline float C_AIPROJSPAWN::attackdmg() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AIPROJSPAWN.attackDmg)
  return _internal_attackdmg();
}
inline void C_AIPROJSPAWN::_internal_set_attackdmg(float value) {
  
  _impl_.attackdmg_ = value;
}
inline void C_AIPROJSPAWN::set_attackdmg(float value) {
  _internal_set_attackdmg(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AIPROJSPAWN.attackDmg)
}

// -------------------------------------------------------------------

// S_AI_KNOCKS_BACK

// uint64 object_id = 1;
inline void S_AI_KNOCKS_BACK::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_AI_KNOCKS_BACK::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_AI_KNOCKS_BACK::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AI_KNOCKS_BACK.object_id)
  return _internal_object_id();
}
inline void S_AI_KNOCKS_BACK::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_AI_KNOCKS_BACK::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AI_KNOCKS_BACK.object_id)
}

// uint64 target_id = 2;
inline void S_AI_KNOCKS_BACK::clear_target_id() {
  _impl_.target_id_ = uint64_t{0u};
}
inline uint64_t S_AI_KNOCKS_BACK::_internal_target_id() const {
  return _impl_.target_id_;
}
inline uint64_t S_AI_KNOCKS_BACK::target_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AI_KNOCKS_BACK.target_id)
  return _internal_target_id();
}
inline void S_AI_KNOCKS_BACK::_internal_set_target_id(uint64_t value) {
  
  _impl_.target_id_ = value;
}
inline void S_AI_KNOCKS_BACK::set_target_id(uint64_t value) {
  _internal_set_target_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AI_KNOCKS_BACK.target_id)
}

// float vx = 3;
inline void S_AI_KNOCKS_BACK::clear_vx() {
  _impl_.vx_ = 0;
}
inline float S_AI_KNOCKS_BACK::_internal_vx() const {
  return _impl_.vx_;
}
inline float S_AI_KNOCKS_BACK::vx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AI_KNOCKS_BACK.vx)
  return _internal_vx();
}
inline void S_AI_KNOCKS_BACK::_internal_set_vx(float value) {
  
  _impl_.vx_ = value;
}
inline void S_AI_KNOCKS_BACK::set_vx(float value) {
  _internal_set_vx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AI_KNOCKS_BACK.vx)
}

// float vy = 4;
inline void S_AI_KNOCKS_BACK::clear_vy() {
  _impl_.vy_ = 0;
}
inline float S_AI_KNOCKS_BACK::_internal_vy() const {
  return _impl_.vy_;
}
inline float S_AI_KNOCKS_BACK::vy() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AI_KNOCKS_BACK.vy)
  return _internal_vy();
}
inline void S_AI_KNOCKS_BACK::_internal_set_vy(float value) {
  
  _impl_.vy_ = value;
}
inline void S_AI_KNOCKS_BACK::set_vy(float value) {
  _internal_set_vy(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AI_KNOCKS_BACK.vy)
}

// float vz = 5;
inline void S_AI_KNOCKS_BACK::clear_vz() {
  _impl_.vz_ = 0;
}
inline float S_AI_KNOCKS_BACK::_internal_vz() const {
  return _impl_.vz_;
}
inline float S_AI_KNOCKS_BACK::vz() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AI_KNOCKS_BACK.vz)
  return _internal_vz();
}
inline void S_AI_KNOCKS_BACK::_internal_set_vz(float value) {
  
  _impl_.vz_ = value;
}
inline void S_AI_KNOCKS_BACK::set_vz(float value) {
  _internal_set_vz(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AI_KNOCKS_BACK.vz)
}

// -------------------------------------------------------------------

// C_AI_KNOCKS_BACK

// uint64 object_id = 1;
inline void C_AI_KNOCKS_BACK::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_AI_KNOCKS_BACK::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_AI_KNOCKS_BACK::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AI_KNOCKS_BACK.object_id)
  return _internal_object_id();
}
inline void C_AI_KNOCKS_BACK::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_AI_KNOCKS_BACK::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AI_KNOCKS_BACK.object_id)
}

// uint64 target_id = 2;
inline void C_AI_KNOCKS_BACK::clear_target_id() {
  _impl_.target_id_ = uint64_t{0u};
}
inline uint64_t C_AI_KNOCKS_BACK::_internal_target_id() const {
  return _impl_.target_id_;
}
inline uint64_t C_AI_KNOCKS_BACK::target_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AI_KNOCKS_BACK.target_id)
  return _internal_target_id();
}
inline void C_AI_KNOCKS_BACK::_internal_set_target_id(uint64_t value) {
  
  _impl_.target_id_ = value;
}
inline void C_AI_KNOCKS_BACK::set_target_id(uint64_t value) {
  _internal_set_target_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AI_KNOCKS_BACK.target_id)
}

// float vx = 3;
inline void C_AI_KNOCKS_BACK::clear_vx() {
  _impl_.vx_ = 0;
}
inline float C_AI_KNOCKS_BACK::_internal_vx() const {
  return _impl_.vx_;
}
inline float C_AI_KNOCKS_BACK::vx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AI_KNOCKS_BACK.vx)
  return _internal_vx();
}
inline void C_AI_KNOCKS_BACK::_internal_set_vx(float value) {
  
  _impl_.vx_ = value;
}
inline void C_AI_KNOCKS_BACK::set_vx(float value) {
  _internal_set_vx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AI_KNOCKS_BACK.vx)
}

// float vy = 4;
inline void C_AI_KNOCKS_BACK::clear_vy() {
  _impl_.vy_ = 0;
}
inline float C_AI_KNOCKS_BACK::_internal_vy() const {
  return _impl_.vy_;
}
inline float C_AI_KNOCKS_BACK::vy() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AI_KNOCKS_BACK.vy)
  return _internal_vy();
}
inline void C_AI_KNOCKS_BACK::_internal_set_vy(float value) {
  
  _impl_.vy_ = value;
}
inline void C_AI_KNOCKS_BACK::set_vy(float value) {
  _internal_set_vy(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AI_KNOCKS_BACK.vy)
}

// float vz = 5;
inline void C_AI_KNOCKS_BACK::clear_vz() {
  _impl_.vz_ = 0;
}
inline float C_AI_KNOCKS_BACK::_internal_vz() const {
  return _impl_.vz_;
}
inline float C_AI_KNOCKS_BACK::vz() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AI_KNOCKS_BACK.vz)
  return _internal_vz();
}
inline void C_AI_KNOCKS_BACK::_internal_set_vz(float value) {
  
  _impl_.vz_ = value;
}
inline void C_AI_KNOCKS_BACK::set_vz(float value) {
  _internal_set_vz(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AI_KNOCKS_BACK.vz)
}

// -------------------------------------------------------------------

// S_PLAYERSKILL_BOMB

// uint64 object_id = 1;
inline void S_PLAYERSKILL_BOMB::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_PLAYERSKILL_BOMB::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_PLAYERSKILL_BOMB::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_BOMB.object_id)
  return _internal_object_id();
}
inline void S_PLAYERSKILL_BOMB::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_PLAYERSKILL_BOMB::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_BOMB.object_id)
}

// uint64 abilityArrayIdx = 2;
inline void S_PLAYERSKILL_BOMB::clear_abilityarrayidx() {
  _impl_.abilityarrayidx_ = uint64_t{0u};
}
inline uint64_t S_PLAYERSKILL_BOMB::_internal_abilityarrayidx() const {
  return _impl_.abilityarrayidx_;
}
inline uint64_t S_PLAYERSKILL_BOMB::abilityarrayidx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_BOMB.abilityArrayIdx)
  return _internal_abilityarrayidx();
}
inline void S_PLAYERSKILL_BOMB::_internal_set_abilityarrayidx(uint64_t value) {
  
  _impl_.abilityarrayidx_ = value;
}
inline void S_PLAYERSKILL_BOMB::set_abilityarrayidx(uint64_t value) {
  _internal_set_abilityarrayidx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_BOMB.abilityArrayIdx)
}

// float x = 3;
inline void S_PLAYERSKILL_BOMB::clear_x() {
  _impl_.x_ = 0;
}
inline float S_PLAYERSKILL_BOMB::_internal_x() const {
  return _impl_.x_;
}
inline float S_PLAYERSKILL_BOMB::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_BOMB.x)
  return _internal_x();
}
inline void S_PLAYERSKILL_BOMB::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void S_PLAYERSKILL_BOMB::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_BOMB.x)
}

// float y = 4;
inline void S_PLAYERSKILL_BOMB::clear_y() {
  _impl_.y_ = 0;
}
inline float S_PLAYERSKILL_BOMB::_internal_y() const {
  return _impl_.y_;
}
inline float S_PLAYERSKILL_BOMB::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_BOMB.y)
  return _internal_y();
}
inline void S_PLAYERSKILL_BOMB::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void S_PLAYERSKILL_BOMB::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_BOMB.y)
}

// float z = 5;
inline void S_PLAYERSKILL_BOMB::clear_z() {
  _impl_.z_ = 0;
}
inline float S_PLAYERSKILL_BOMB::_internal_z() const {
  return _impl_.z_;
}
inline float S_PLAYERSKILL_BOMB::z() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_BOMB.z)
  return _internal_z();
}
inline void S_PLAYERSKILL_BOMB::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void S_PLAYERSKILL_BOMB::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_BOMB.z)
}

// float dmg = 6;
inline void S_PLAYERSKILL_BOMB::clear_dmg() {
  _impl_.dmg_ = 0;
}
inline float S_PLAYERSKILL_BOMB::_internal_dmg() const {
  return _impl_.dmg_;
}
inline float S_PLAYERSKILL_BOMB::dmg() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_BOMB.dmg)
  return _internal_dmg();
}
inline void S_PLAYERSKILL_BOMB::_internal_set_dmg(float value) {
  
  _impl_.dmg_ = value;
}
inline void S_PLAYERSKILL_BOMB::set_dmg(float value) {
  _internal_set_dmg(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_BOMB.dmg)
}

// -------------------------------------------------------------------

// C_PLAYERSKILL_BOMB

// uint64 object_id = 1;
inline void C_PLAYERSKILL_BOMB::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_PLAYERSKILL_BOMB::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_PLAYERSKILL_BOMB::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_BOMB.object_id)
  return _internal_object_id();
}
inline void C_PLAYERSKILL_BOMB::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_PLAYERSKILL_BOMB::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_BOMB.object_id)
}

// uint64 abilityArrayIdx = 2;
inline void C_PLAYERSKILL_BOMB::clear_abilityarrayidx() {
  _impl_.abilityarrayidx_ = uint64_t{0u};
}
inline uint64_t C_PLAYERSKILL_BOMB::_internal_abilityarrayidx() const {
  return _impl_.abilityarrayidx_;
}
inline uint64_t C_PLAYERSKILL_BOMB::abilityarrayidx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_BOMB.abilityArrayIdx)
  return _internal_abilityarrayidx();
}
inline void C_PLAYERSKILL_BOMB::_internal_set_abilityarrayidx(uint64_t value) {
  
  _impl_.abilityarrayidx_ = value;
}
inline void C_PLAYERSKILL_BOMB::set_abilityarrayidx(uint64_t value) {
  _internal_set_abilityarrayidx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_BOMB.abilityArrayIdx)
}

// float x = 3;
inline void C_PLAYERSKILL_BOMB::clear_x() {
  _impl_.x_ = 0;
}
inline float C_PLAYERSKILL_BOMB::_internal_x() const {
  return _impl_.x_;
}
inline float C_PLAYERSKILL_BOMB::x() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_BOMB.x)
  return _internal_x();
}
inline void C_PLAYERSKILL_BOMB::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void C_PLAYERSKILL_BOMB::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_BOMB.x)
}

// float y = 4;
inline void C_PLAYERSKILL_BOMB::clear_y() {
  _impl_.y_ = 0;
}
inline float C_PLAYERSKILL_BOMB::_internal_y() const {
  return _impl_.y_;
}
inline float C_PLAYERSKILL_BOMB::y() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_BOMB.y)
  return _internal_y();
}
inline void C_PLAYERSKILL_BOMB::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void C_PLAYERSKILL_BOMB::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_BOMB.y)
}

// float z = 5;
inline void C_PLAYERSKILL_BOMB::clear_z() {
  _impl_.z_ = 0;
}
inline float C_PLAYERSKILL_BOMB::_internal_z() const {
  return _impl_.z_;
}
inline float C_PLAYERSKILL_BOMB::z() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_BOMB.z)
  return _internal_z();
}
inline void C_PLAYERSKILL_BOMB::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void C_PLAYERSKILL_BOMB::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_BOMB.z)
}

// float dmg = 6;
inline void C_PLAYERSKILL_BOMB::clear_dmg() {
  _impl_.dmg_ = 0;
}
inline float C_PLAYERSKILL_BOMB::_internal_dmg() const {
  return _impl_.dmg_;
}
inline float C_PLAYERSKILL_BOMB::dmg() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_BOMB.dmg)
  return _internal_dmg();
}
inline void C_PLAYERSKILL_BOMB::_internal_set_dmg(float value) {
  
  _impl_.dmg_ = value;
}
inline void C_PLAYERSKILL_BOMB::set_dmg(float value) {
  _internal_set_dmg(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_BOMB.dmg)
}

// -------------------------------------------------------------------

// S_PLAYERSKILL_GRANADE

// uint64 object_id = 1;
inline void S_PLAYERSKILL_GRANADE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_PLAYERSKILL_GRANADE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_PLAYERSKILL_GRANADE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_GRANADE.object_id)
  return _internal_object_id();
}
inline void S_PLAYERSKILL_GRANADE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_PLAYERSKILL_GRANADE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_GRANADE.object_id)
}

// uint64 abilityArrayIdx = 2;
inline void S_PLAYERSKILL_GRANADE::clear_abilityarrayidx() {
  _impl_.abilityarrayidx_ = uint64_t{0u};
}
inline uint64_t S_PLAYERSKILL_GRANADE::_internal_abilityarrayidx() const {
  return _impl_.abilityarrayidx_;
}
inline uint64_t S_PLAYERSKILL_GRANADE::abilityarrayidx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_GRANADE.abilityArrayIdx)
  return _internal_abilityarrayidx();
}
inline void S_PLAYERSKILL_GRANADE::_internal_set_abilityarrayidx(uint64_t value) {
  
  _impl_.abilityarrayidx_ = value;
}
inline void S_PLAYERSKILL_GRANADE::set_abilityarrayidx(uint64_t value) {
  _internal_set_abilityarrayidx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_GRANADE.abilityArrayIdx)
}

// float x = 3;
inline void S_PLAYERSKILL_GRANADE::clear_x() {
  _impl_.x_ = 0;
}
inline float S_PLAYERSKILL_GRANADE::_internal_x() const {
  return _impl_.x_;
}
inline float S_PLAYERSKILL_GRANADE::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_GRANADE.x)
  return _internal_x();
}
inline void S_PLAYERSKILL_GRANADE::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void S_PLAYERSKILL_GRANADE::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_GRANADE.x)
}

// float y = 4;
inline void S_PLAYERSKILL_GRANADE::clear_y() {
  _impl_.y_ = 0;
}
inline float S_PLAYERSKILL_GRANADE::_internal_y() const {
  return _impl_.y_;
}
inline float S_PLAYERSKILL_GRANADE::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_GRANADE.y)
  return _internal_y();
}
inline void S_PLAYERSKILL_GRANADE::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void S_PLAYERSKILL_GRANADE::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_GRANADE.y)
}

// float z = 5;
inline void S_PLAYERSKILL_GRANADE::clear_z() {
  _impl_.z_ = 0;
}
inline float S_PLAYERSKILL_GRANADE::_internal_z() const {
  return _impl_.z_;
}
inline float S_PLAYERSKILL_GRANADE::z() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_GRANADE.z)
  return _internal_z();
}
inline void S_PLAYERSKILL_GRANADE::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void S_PLAYERSKILL_GRANADE::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_GRANADE.z)
}

// float rx = 6;
inline void S_PLAYERSKILL_GRANADE::clear_rx() {
  _impl_.rx_ = 0;
}
inline float S_PLAYERSKILL_GRANADE::_internal_rx() const {
  return _impl_.rx_;
}
inline float S_PLAYERSKILL_GRANADE::rx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_GRANADE.rx)
  return _internal_rx();
}
inline void S_PLAYERSKILL_GRANADE::_internal_set_rx(float value) {
  
  _impl_.rx_ = value;
}
inline void S_PLAYERSKILL_GRANADE::set_rx(float value) {
  _internal_set_rx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_GRANADE.rx)
}

// float ry = 7;
inline void S_PLAYERSKILL_GRANADE::clear_ry() {
  _impl_.ry_ = 0;
}
inline float S_PLAYERSKILL_GRANADE::_internal_ry() const {
  return _impl_.ry_;
}
inline float S_PLAYERSKILL_GRANADE::ry() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_GRANADE.ry)
  return _internal_ry();
}
inline void S_PLAYERSKILL_GRANADE::_internal_set_ry(float value) {
  
  _impl_.ry_ = value;
}
inline void S_PLAYERSKILL_GRANADE::set_ry(float value) {
  _internal_set_ry(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_GRANADE.ry)
}

// float rz = 8;
inline void S_PLAYERSKILL_GRANADE::clear_rz() {
  _impl_.rz_ = 0;
}
inline float S_PLAYERSKILL_GRANADE::_internal_rz() const {
  return _impl_.rz_;
}
inline float S_PLAYERSKILL_GRANADE::rz() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_GRANADE.rz)
  return _internal_rz();
}
inline void S_PLAYERSKILL_GRANADE::_internal_set_rz(float value) {
  
  _impl_.rz_ = value;
}
inline void S_PLAYERSKILL_GRANADE::set_rz(float value) {
  _internal_set_rz(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_GRANADE.rz)
}

// float dmg = 9;
inline void S_PLAYERSKILL_GRANADE::clear_dmg() {
  _impl_.dmg_ = 0;
}
inline float S_PLAYERSKILL_GRANADE::_internal_dmg() const {
  return _impl_.dmg_;
}
inline float S_PLAYERSKILL_GRANADE::dmg() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_GRANADE.dmg)
  return _internal_dmg();
}
inline void S_PLAYERSKILL_GRANADE::_internal_set_dmg(float value) {
  
  _impl_.dmg_ = value;
}
inline void S_PLAYERSKILL_GRANADE::set_dmg(float value) {
  _internal_set_dmg(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_GRANADE.dmg)
}

// -------------------------------------------------------------------

// C_PLAYERSKILL_GRANADE

// uint64 object_id = 1;
inline void C_PLAYERSKILL_GRANADE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_PLAYERSKILL_GRANADE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_PLAYERSKILL_GRANADE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_GRANADE.object_id)
  return _internal_object_id();
}
inline void C_PLAYERSKILL_GRANADE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_PLAYERSKILL_GRANADE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_GRANADE.object_id)
}

// uint64 abilityArrayIdx = 2;
inline void C_PLAYERSKILL_GRANADE::clear_abilityarrayidx() {
  _impl_.abilityarrayidx_ = uint64_t{0u};
}
inline uint64_t C_PLAYERSKILL_GRANADE::_internal_abilityarrayidx() const {
  return _impl_.abilityarrayidx_;
}
inline uint64_t C_PLAYERSKILL_GRANADE::abilityarrayidx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_GRANADE.abilityArrayIdx)
  return _internal_abilityarrayidx();
}
inline void C_PLAYERSKILL_GRANADE::_internal_set_abilityarrayidx(uint64_t value) {
  
  _impl_.abilityarrayidx_ = value;
}
inline void C_PLAYERSKILL_GRANADE::set_abilityarrayidx(uint64_t value) {
  _internal_set_abilityarrayidx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_GRANADE.abilityArrayIdx)
}

// float x = 3;
inline void C_PLAYERSKILL_GRANADE::clear_x() {
  _impl_.x_ = 0;
}
inline float C_PLAYERSKILL_GRANADE::_internal_x() const {
  return _impl_.x_;
}
inline float C_PLAYERSKILL_GRANADE::x() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_GRANADE.x)
  return _internal_x();
}
inline void C_PLAYERSKILL_GRANADE::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void C_PLAYERSKILL_GRANADE::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_GRANADE.x)
}

// float y = 4;
inline void C_PLAYERSKILL_GRANADE::clear_y() {
  _impl_.y_ = 0;
}
inline float C_PLAYERSKILL_GRANADE::_internal_y() const {
  return _impl_.y_;
}
inline float C_PLAYERSKILL_GRANADE::y() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_GRANADE.y)
  return _internal_y();
}
inline void C_PLAYERSKILL_GRANADE::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void C_PLAYERSKILL_GRANADE::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_GRANADE.y)
}

// float z = 5;
inline void C_PLAYERSKILL_GRANADE::clear_z() {
  _impl_.z_ = 0;
}
inline float C_PLAYERSKILL_GRANADE::_internal_z() const {
  return _impl_.z_;
}
inline float C_PLAYERSKILL_GRANADE::z() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_GRANADE.z)
  return _internal_z();
}
inline void C_PLAYERSKILL_GRANADE::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void C_PLAYERSKILL_GRANADE::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_GRANADE.z)
}

// float rx = 6;
inline void C_PLAYERSKILL_GRANADE::clear_rx() {
  _impl_.rx_ = 0;
}
inline float C_PLAYERSKILL_GRANADE::_internal_rx() const {
  return _impl_.rx_;
}
inline float C_PLAYERSKILL_GRANADE::rx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_GRANADE.rx)
  return _internal_rx();
}
inline void C_PLAYERSKILL_GRANADE::_internal_set_rx(float value) {
  
  _impl_.rx_ = value;
}
inline void C_PLAYERSKILL_GRANADE::set_rx(float value) {
  _internal_set_rx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_GRANADE.rx)
}

// float ry = 7;
inline void C_PLAYERSKILL_GRANADE::clear_ry() {
  _impl_.ry_ = 0;
}
inline float C_PLAYERSKILL_GRANADE::_internal_ry() const {
  return _impl_.ry_;
}
inline float C_PLAYERSKILL_GRANADE::ry() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_GRANADE.ry)
  return _internal_ry();
}
inline void C_PLAYERSKILL_GRANADE::_internal_set_ry(float value) {
  
  _impl_.ry_ = value;
}
inline void C_PLAYERSKILL_GRANADE::set_ry(float value) {
  _internal_set_ry(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_GRANADE.ry)
}

// float rz = 8;
inline void C_PLAYERSKILL_GRANADE::clear_rz() {
  _impl_.rz_ = 0;
}
inline float C_PLAYERSKILL_GRANADE::_internal_rz() const {
  return _impl_.rz_;
}
inline float C_PLAYERSKILL_GRANADE::rz() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_GRANADE.rz)
  return _internal_rz();
}
inline void C_PLAYERSKILL_GRANADE::_internal_set_rz(float value) {
  
  _impl_.rz_ = value;
}
inline void C_PLAYERSKILL_GRANADE::set_rz(float value) {
  _internal_set_rz(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_GRANADE.rz)
}

// float dmg = 9;
inline void C_PLAYERSKILL_GRANADE::clear_dmg() {
  _impl_.dmg_ = 0;
}
inline float C_PLAYERSKILL_GRANADE::_internal_dmg() const {
  return _impl_.dmg_;
}
inline float C_PLAYERSKILL_GRANADE::dmg() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_GRANADE.dmg)
  return _internal_dmg();
}
inline void C_PLAYERSKILL_GRANADE::_internal_set_dmg(float value) {
  
  _impl_.dmg_ = value;
}
inline void C_PLAYERSKILL_GRANADE::set_dmg(float value) {
  _internal_set_dmg(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_GRANADE.dmg)
}

// -------------------------------------------------------------------

// S_PLAYERSKILL_CHEMICAL

// uint64 object_id = 1;
inline void S_PLAYERSKILL_CHEMICAL::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_PLAYERSKILL_CHEMICAL::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_PLAYERSKILL_CHEMICAL::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_CHEMICAL.object_id)
  return _internal_object_id();
}
inline void S_PLAYERSKILL_CHEMICAL::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_PLAYERSKILL_CHEMICAL::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_CHEMICAL.object_id)
}

// uint64 abilityArrayIdx = 2;
inline void S_PLAYERSKILL_CHEMICAL::clear_abilityarrayidx() {
  _impl_.abilityarrayidx_ = uint64_t{0u};
}
inline uint64_t S_PLAYERSKILL_CHEMICAL::_internal_abilityarrayidx() const {
  return _impl_.abilityarrayidx_;
}
inline uint64_t S_PLAYERSKILL_CHEMICAL::abilityarrayidx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_CHEMICAL.abilityArrayIdx)
  return _internal_abilityarrayidx();
}
inline void S_PLAYERSKILL_CHEMICAL::_internal_set_abilityarrayidx(uint64_t value) {
  
  _impl_.abilityarrayidx_ = value;
}
inline void S_PLAYERSKILL_CHEMICAL::set_abilityarrayidx(uint64_t value) {
  _internal_set_abilityarrayidx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_CHEMICAL.abilityArrayIdx)
}

// float x = 3;
inline void S_PLAYERSKILL_CHEMICAL::clear_x() {
  _impl_.x_ = 0;
}
inline float S_PLAYERSKILL_CHEMICAL::_internal_x() const {
  return _impl_.x_;
}
inline float S_PLAYERSKILL_CHEMICAL::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_CHEMICAL.x)
  return _internal_x();
}
inline void S_PLAYERSKILL_CHEMICAL::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void S_PLAYERSKILL_CHEMICAL::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_CHEMICAL.x)
}

// float y = 4;
inline void S_PLAYERSKILL_CHEMICAL::clear_y() {
  _impl_.y_ = 0;
}
inline float S_PLAYERSKILL_CHEMICAL::_internal_y() const {
  return _impl_.y_;
}
inline float S_PLAYERSKILL_CHEMICAL::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_CHEMICAL.y)
  return _internal_y();
}
inline void S_PLAYERSKILL_CHEMICAL::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void S_PLAYERSKILL_CHEMICAL::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_CHEMICAL.y)
}

// float z = 5;
inline void S_PLAYERSKILL_CHEMICAL::clear_z() {
  _impl_.z_ = 0;
}
inline float S_PLAYERSKILL_CHEMICAL::_internal_z() const {
  return _impl_.z_;
}
inline float S_PLAYERSKILL_CHEMICAL::z() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_CHEMICAL.z)
  return _internal_z();
}
inline void S_PLAYERSKILL_CHEMICAL::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void S_PLAYERSKILL_CHEMICAL::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_CHEMICAL.z)
}

// float dmg = 6;
inline void S_PLAYERSKILL_CHEMICAL::clear_dmg() {
  _impl_.dmg_ = 0;
}
inline float S_PLAYERSKILL_CHEMICAL::_internal_dmg() const {
  return _impl_.dmg_;
}
inline float S_PLAYERSKILL_CHEMICAL::dmg() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_CHEMICAL.dmg)
  return _internal_dmg();
}
inline void S_PLAYERSKILL_CHEMICAL::_internal_set_dmg(float value) {
  
  _impl_.dmg_ = value;
}
inline void S_PLAYERSKILL_CHEMICAL::set_dmg(float value) {
  _internal_set_dmg(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_CHEMICAL.dmg)
}

// -------------------------------------------------------------------

// C_PLAYERSKILL_CHEMICAL

// uint64 object_id = 1;
inline void C_PLAYERSKILL_CHEMICAL::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_PLAYERSKILL_CHEMICAL::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_PLAYERSKILL_CHEMICAL::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_CHEMICAL.object_id)
  return _internal_object_id();
}
inline void C_PLAYERSKILL_CHEMICAL::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_PLAYERSKILL_CHEMICAL::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_CHEMICAL.object_id)
}

// uint64 abilityArrayIdx = 2;
inline void C_PLAYERSKILL_CHEMICAL::clear_abilityarrayidx() {
  _impl_.abilityarrayidx_ = uint64_t{0u};
}
inline uint64_t C_PLAYERSKILL_CHEMICAL::_internal_abilityarrayidx() const {
  return _impl_.abilityarrayidx_;
}
inline uint64_t C_PLAYERSKILL_CHEMICAL::abilityarrayidx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_CHEMICAL.abilityArrayIdx)
  return _internal_abilityarrayidx();
}
inline void C_PLAYERSKILL_CHEMICAL::_internal_set_abilityarrayidx(uint64_t value) {
  
  _impl_.abilityarrayidx_ = value;
}
inline void C_PLAYERSKILL_CHEMICAL::set_abilityarrayidx(uint64_t value) {
  _internal_set_abilityarrayidx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_CHEMICAL.abilityArrayIdx)
}

// float x = 3;
inline void C_PLAYERSKILL_CHEMICAL::clear_x() {
  _impl_.x_ = 0;
}
inline float C_PLAYERSKILL_CHEMICAL::_internal_x() const {
  return _impl_.x_;
}
inline float C_PLAYERSKILL_CHEMICAL::x() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_CHEMICAL.x)
  return _internal_x();
}
inline void C_PLAYERSKILL_CHEMICAL::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void C_PLAYERSKILL_CHEMICAL::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_CHEMICAL.x)
}

// float y = 4;
inline void C_PLAYERSKILL_CHEMICAL::clear_y() {
  _impl_.y_ = 0;
}
inline float C_PLAYERSKILL_CHEMICAL::_internal_y() const {
  return _impl_.y_;
}
inline float C_PLAYERSKILL_CHEMICAL::y() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_CHEMICAL.y)
  return _internal_y();
}
inline void C_PLAYERSKILL_CHEMICAL::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void C_PLAYERSKILL_CHEMICAL::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_CHEMICAL.y)
}

// float z = 5;
inline void C_PLAYERSKILL_CHEMICAL::clear_z() {
  _impl_.z_ = 0;
}
inline float C_PLAYERSKILL_CHEMICAL::_internal_z() const {
  return _impl_.z_;
}
inline float C_PLAYERSKILL_CHEMICAL::z() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_CHEMICAL.z)
  return _internal_z();
}
inline void C_PLAYERSKILL_CHEMICAL::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void C_PLAYERSKILL_CHEMICAL::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_CHEMICAL.z)
}

// float dmg = 6;
inline void C_PLAYERSKILL_CHEMICAL::clear_dmg() {
  _impl_.dmg_ = 0;
}
inline float C_PLAYERSKILL_CHEMICAL::_internal_dmg() const {
  return _impl_.dmg_;
}
inline float C_PLAYERSKILL_CHEMICAL::dmg() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_CHEMICAL.dmg)
  return _internal_dmg();
}
inline void C_PLAYERSKILL_CHEMICAL::_internal_set_dmg(float value) {
  
  _impl_.dmg_ = value;
}
inline void C_PLAYERSKILL_CHEMICAL::set_dmg(float value) {
  _internal_set_dmg(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_CHEMICAL.dmg)
}

// -------------------------------------------------------------------

// S_PLAYERSKILL_GUARD

// uint64 object_id = 1;
inline void S_PLAYERSKILL_GUARD::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_PLAYERSKILL_GUARD::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_PLAYERSKILL_GUARD::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_GUARD.object_id)
  return _internal_object_id();
}
inline void S_PLAYERSKILL_GUARD::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_PLAYERSKILL_GUARD::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_GUARD.object_id)
}

// uint64 guardPoint = 2;
inline void S_PLAYERSKILL_GUARD::clear_guardpoint() {
  _impl_.guardpoint_ = uint64_t{0u};
}
inline uint64_t S_PLAYERSKILL_GUARD::_internal_guardpoint() const {
  return _impl_.guardpoint_;
}
inline uint64_t S_PLAYERSKILL_GUARD::guardpoint() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_GUARD.guardPoint)
  return _internal_guardpoint();
}
inline void S_PLAYERSKILL_GUARD::_internal_set_guardpoint(uint64_t value) {
  
  _impl_.guardpoint_ = value;
}
inline void S_PLAYERSKILL_GUARD::set_guardpoint(uint64_t value) {
  _internal_set_guardpoint(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_GUARD.guardPoint)
}

// -------------------------------------------------------------------

// C_PLAYERSKILL_GUARD

// uint64 object_id = 1;
inline void C_PLAYERSKILL_GUARD::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_PLAYERSKILL_GUARD::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_PLAYERSKILL_GUARD::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_GUARD.object_id)
  return _internal_object_id();
}
inline void C_PLAYERSKILL_GUARD::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_PLAYERSKILL_GUARD::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_GUARD.object_id)
}

// uint64 guardPoint = 2;
inline void C_PLAYERSKILL_GUARD::clear_guardpoint() {
  _impl_.guardpoint_ = uint64_t{0u};
}
inline uint64_t C_PLAYERSKILL_GUARD::_internal_guardpoint() const {
  return _impl_.guardpoint_;
}
inline uint64_t C_PLAYERSKILL_GUARD::guardpoint() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_GUARD.guardPoint)
  return _internal_guardpoint();
}
inline void C_PLAYERSKILL_GUARD::_internal_set_guardpoint(uint64_t value) {
  
  _impl_.guardpoint_ = value;
}
inline void C_PLAYERSKILL_GUARD::set_guardpoint(uint64_t value) {
  _internal_set_guardpoint(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_GUARD.guardPoint)
}

// -------------------------------------------------------------------

// S_PLAYERSKILL_HEAL

// uint64 object_id = 1;
inline void S_PLAYERSKILL_HEAL::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_PLAYERSKILL_HEAL::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_PLAYERSKILL_HEAL::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_HEAL.object_id)
  return _internal_object_id();
}
inline void S_PLAYERSKILL_HEAL::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_PLAYERSKILL_HEAL::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_HEAL.object_id)
}

// uint64 abilityArrayIdx = 2;
inline void S_PLAYERSKILL_HEAL::clear_abilityarrayidx() {
  _impl_.abilityarrayidx_ = uint64_t{0u};
}
inline uint64_t S_PLAYERSKILL_HEAL::_internal_abilityarrayidx() const {
  return _impl_.abilityarrayidx_;
}
inline uint64_t S_PLAYERSKILL_HEAL::abilityarrayidx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERSKILL_HEAL.abilityArrayIdx)
  return _internal_abilityarrayidx();
}
inline void S_PLAYERSKILL_HEAL::_internal_set_abilityarrayidx(uint64_t value) {
  
  _impl_.abilityarrayidx_ = value;
}
inline void S_PLAYERSKILL_HEAL::set_abilityarrayidx(uint64_t value) {
  _internal_set_abilityarrayidx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERSKILL_HEAL.abilityArrayIdx)
}

// -------------------------------------------------------------------

// C_PLAYERSKILL_HEAL

// uint64 object_id = 1;
inline void C_PLAYERSKILL_HEAL::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_PLAYERSKILL_HEAL::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_PLAYERSKILL_HEAL::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_HEAL.object_id)
  return _internal_object_id();
}
inline void C_PLAYERSKILL_HEAL::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_PLAYERSKILL_HEAL::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_HEAL.object_id)
}

// uint64 abilityArrayIdx = 2;
inline void C_PLAYERSKILL_HEAL::clear_abilityarrayidx() {
  _impl_.abilityarrayidx_ = uint64_t{0u};
}
inline uint64_t C_PLAYERSKILL_HEAL::_internal_abilityarrayidx() const {
  return _impl_.abilityarrayidx_;
}
inline uint64_t C_PLAYERSKILL_HEAL::abilityarrayidx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERSKILL_HEAL.abilityArrayIdx)
  return _internal_abilityarrayidx();
}
inline void C_PLAYERSKILL_HEAL::_internal_set_abilityarrayidx(uint64_t value) {
  
  _impl_.abilityarrayidx_ = value;
}
inline void C_PLAYERSKILL_HEAL::set_abilityarrayidx(uint64_t value) {
  _internal_set_abilityarrayidx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERSKILL_HEAL.abilityArrayIdx)
}

// -------------------------------------------------------------------

// S_PLAYERHEAL

// uint64 object_id = 1;
inline void S_PLAYERHEAL::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_PLAYERHEAL::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_PLAYERHEAL::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERHEAL.object_id)
  return _internal_object_id();
}
inline void S_PLAYERHEAL::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_PLAYERHEAL::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERHEAL.object_id)
}

// uint64 updeatedHP = 2;
inline void S_PLAYERHEAL::clear_updeatedhp() {
  _impl_.updeatedhp_ = uint64_t{0u};
}
inline uint64_t S_PLAYERHEAL::_internal_updeatedhp() const {
  return _impl_.updeatedhp_;
}
inline uint64_t S_PLAYERHEAL::updeatedhp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PLAYERHEAL.updeatedHP)
  return _internal_updeatedhp();
}
inline void S_PLAYERHEAL::_internal_set_updeatedhp(uint64_t value) {
  
  _impl_.updeatedhp_ = value;
}
inline void S_PLAYERHEAL::set_updeatedhp(uint64_t value) {
  _internal_set_updeatedhp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PLAYERHEAL.updeatedHP)
}

// -------------------------------------------------------------------

// C_PLAYERHEAL

// uint64 object_id = 1;
inline void C_PLAYERHEAL::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_PLAYERHEAL::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_PLAYERHEAL::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERHEAL.object_id)
  return _internal_object_id();
}
inline void C_PLAYERHEAL::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_PLAYERHEAL::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERHEAL.object_id)
}

// uint64 updeatedHP = 2;
inline void C_PLAYERHEAL::clear_updeatedhp() {
  _impl_.updeatedhp_ = uint64_t{0u};
}
inline uint64_t C_PLAYERHEAL::_internal_updeatedhp() const {
  return _impl_.updeatedhp_;
}
inline uint64_t C_PLAYERHEAL::updeatedhp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PLAYERHEAL.updeatedHP)
  return _internal_updeatedhp();
}
inline void C_PLAYERHEAL::_internal_set_updeatedhp(uint64_t value) {
  
  _impl_.updeatedhp_ = value;
}
inline void C_PLAYERHEAL::set_updeatedhp(uint64_t value) {
  _internal_set_updeatedhp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_PLAYERHEAL.updeatedHP)
}

// -------------------------------------------------------------------

// S_MAKEDRONE

// uint64 object_id = 1;
inline void S_MAKEDRONE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_MAKEDRONE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_MAKEDRONE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MAKEDRONE.object_id)
  return _internal_object_id();
}
inline void S_MAKEDRONE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_MAKEDRONE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_MAKEDRONE.object_id)
}

// uint64 abilityArrayIdx = 2;
inline void S_MAKEDRONE::clear_abilityarrayidx() {
  _impl_.abilityarrayidx_ = uint64_t{0u};
}
inline uint64_t S_MAKEDRONE::_internal_abilityarrayidx() const {
  return _impl_.abilityarrayidx_;
}
inline uint64_t S_MAKEDRONE::abilityarrayidx() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MAKEDRONE.abilityArrayIdx)
  return _internal_abilityarrayidx();
}
inline void S_MAKEDRONE::_internal_set_abilityarrayidx(uint64_t value) {
  
  _impl_.abilityarrayidx_ = value;
}
inline void S_MAKEDRONE::set_abilityarrayidx(uint64_t value) {
  _internal_set_abilityarrayidx(value);
  // @@protoc_insertion_point(field_set:Protocol.S_MAKEDRONE.abilityArrayIdx)
}

// -------------------------------------------------------------------

// C_MAKEDRONE

// uint64 object_id = 1;
inline void C_MAKEDRONE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_MAKEDRONE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_MAKEDRONE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MAKEDRONE.object_id)
  return _internal_object_id();
}
inline void C_MAKEDRONE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_MAKEDRONE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_MAKEDRONE.object_id)
}

// uint64 abilityArrayIdx = 2;
inline void C_MAKEDRONE::clear_abilityarrayidx() {
  _impl_.abilityarrayidx_ = uint64_t{0u};
}
inline uint64_t C_MAKEDRONE::_internal_abilityarrayidx() const {
  return _impl_.abilityarrayidx_;
}
inline uint64_t C_MAKEDRONE::abilityarrayidx() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MAKEDRONE.abilityArrayIdx)
  return _internal_abilityarrayidx();
}
inline void C_MAKEDRONE::_internal_set_abilityarrayidx(uint64_t value) {
  
  _impl_.abilityarrayidx_ = value;
}
inline void C_MAKEDRONE::set_abilityarrayidx(uint64_t value) {
  _internal_set_abilityarrayidx(value);
  // @@protoc_insertion_point(field_set:Protocol.C_MAKEDRONE.abilityArrayIdx)
}

// -------------------------------------------------------------------

// S_MOVEDRONE

// uint64 object_id = 1;
inline void S_MOVEDRONE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_MOVEDRONE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_MOVEDRONE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVEDRONE.object_id)
  return _internal_object_id();
}
inline void S_MOVEDRONE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_MOVEDRONE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_MOVEDRONE.object_id)
}

// float x = 2;
inline void S_MOVEDRONE::clear_x() {
  _impl_.x_ = 0;
}
inline float S_MOVEDRONE::_internal_x() const {
  return _impl_.x_;
}
inline float S_MOVEDRONE::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVEDRONE.x)
  return _internal_x();
}
inline void S_MOVEDRONE::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void S_MOVEDRONE::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_MOVEDRONE.x)
}

// float y = 3;
inline void S_MOVEDRONE::clear_y() {
  _impl_.y_ = 0;
}
inline float S_MOVEDRONE::_internal_y() const {
  return _impl_.y_;
}
inline float S_MOVEDRONE::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVEDRONE.y)
  return _internal_y();
}
inline void S_MOVEDRONE::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void S_MOVEDRONE::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_MOVEDRONE.y)
}

// float z = 4;
inline void S_MOVEDRONE::clear_z() {
  _impl_.z_ = 0;
}
inline float S_MOVEDRONE::_internal_z() const {
  return _impl_.z_;
}
inline float S_MOVEDRONE::z() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVEDRONE.z)
  return _internal_z();
}
inline void S_MOVEDRONE::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void S_MOVEDRONE::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.S_MOVEDRONE.z)
}

// -------------------------------------------------------------------

// C_MOVEDRONE

// uint64 object_id = 1;
inline void C_MOVEDRONE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_MOVEDRONE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_MOVEDRONE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVEDRONE.object_id)
  return _internal_object_id();
}
inline void C_MOVEDRONE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_MOVEDRONE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_MOVEDRONE.object_id)
}

// float x = 2;
inline void C_MOVEDRONE::clear_x() {
  _impl_.x_ = 0;
}
inline float C_MOVEDRONE::_internal_x() const {
  return _impl_.x_;
}
inline float C_MOVEDRONE::x() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVEDRONE.x)
  return _internal_x();
}
inline void C_MOVEDRONE::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void C_MOVEDRONE::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.C_MOVEDRONE.x)
}

// float y = 3;
inline void C_MOVEDRONE::clear_y() {
  _impl_.y_ = 0;
}
inline float C_MOVEDRONE::_internal_y() const {
  return _impl_.y_;
}
inline float C_MOVEDRONE::y() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVEDRONE.y)
  return _internal_y();
}
inline void C_MOVEDRONE::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void C_MOVEDRONE::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.C_MOVEDRONE.y)
}

// float z = 4;
inline void C_MOVEDRONE::clear_z() {
  _impl_.z_ = 0;
}
inline float C_MOVEDRONE::_internal_z() const {
  return _impl_.z_;
}
inline float C_MOVEDRONE::z() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVEDRONE.z)
  return _internal_z();
}
inline void C_MOVEDRONE::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void C_MOVEDRONE::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.C_MOVEDRONE.z)
}

// -------------------------------------------------------------------

// S_SEARCHDRONE

// uint64 object_id = 1;
inline void S_SEARCHDRONE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_SEARCHDRONE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_SEARCHDRONE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SEARCHDRONE.object_id)
  return _internal_object_id();
}
inline void S_SEARCHDRONE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_SEARCHDRONE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SEARCHDRONE.object_id)
}

// float x = 2;
inline void S_SEARCHDRONE::clear_x() {
  _impl_.x_ = 0;
}
inline float S_SEARCHDRONE::_internal_x() const {
  return _impl_.x_;
}
inline float S_SEARCHDRONE::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SEARCHDRONE.x)
  return _internal_x();
}
inline void S_SEARCHDRONE::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void S_SEARCHDRONE::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SEARCHDRONE.x)
}

// float y = 3;
inline void S_SEARCHDRONE::clear_y() {
  _impl_.y_ = 0;
}
inline float S_SEARCHDRONE::_internal_y() const {
  return _impl_.y_;
}
inline float S_SEARCHDRONE::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SEARCHDRONE.y)
  return _internal_y();
}
inline void S_SEARCHDRONE::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void S_SEARCHDRONE::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SEARCHDRONE.y)
}

// float z = 4;
inline void S_SEARCHDRONE::clear_z() {
  _impl_.z_ = 0;
}
inline float S_SEARCHDRONE::_internal_z() const {
  return _impl_.z_;
}
inline float S_SEARCHDRONE::z() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SEARCHDRONE.z)
  return _internal_z();
}
inline void S_SEARCHDRONE::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void S_SEARCHDRONE::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SEARCHDRONE.z)
}

// float yaw = 5;
inline void S_SEARCHDRONE::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float S_SEARCHDRONE::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float S_SEARCHDRONE::yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SEARCHDRONE.yaw)
  return _internal_yaw();
}
inline void S_SEARCHDRONE::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void S_SEARCHDRONE::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SEARCHDRONE.yaw)
}

// float pitch = 6;
inline void S_SEARCHDRONE::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float S_SEARCHDRONE::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float S_SEARCHDRONE::pitch() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SEARCHDRONE.pitch)
  return _internal_pitch();
}
inline void S_SEARCHDRONE::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void S_SEARCHDRONE::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SEARCHDRONE.pitch)
}

// float roll = 7;
inline void S_SEARCHDRONE::clear_roll() {
  _impl_.roll_ = 0;
}
inline float S_SEARCHDRONE::_internal_roll() const {
  return _impl_.roll_;
}
inline float S_SEARCHDRONE::roll() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SEARCHDRONE.roll)
  return _internal_roll();
}
inline void S_SEARCHDRONE::_internal_set_roll(float value) {
  
  _impl_.roll_ = value;
}
inline void S_SEARCHDRONE::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SEARCHDRONE.roll)
}

// -------------------------------------------------------------------

// C_SEARCHDRONE

// uint64 object_id = 1;
inline void C_SEARCHDRONE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_SEARCHDRONE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_SEARCHDRONE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SEARCHDRONE.object_id)
  return _internal_object_id();
}
inline void C_SEARCHDRONE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_SEARCHDRONE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SEARCHDRONE.object_id)
}

// float x = 2;
inline void C_SEARCHDRONE::clear_x() {
  _impl_.x_ = 0;
}
inline float C_SEARCHDRONE::_internal_x() const {
  return _impl_.x_;
}
inline float C_SEARCHDRONE::x() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SEARCHDRONE.x)
  return _internal_x();
}
inline void C_SEARCHDRONE::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void C_SEARCHDRONE::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SEARCHDRONE.x)
}

// float y = 3;
inline void C_SEARCHDRONE::clear_y() {
  _impl_.y_ = 0;
}
inline float C_SEARCHDRONE::_internal_y() const {
  return _impl_.y_;
}
inline float C_SEARCHDRONE::y() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SEARCHDRONE.y)
  return _internal_y();
}
inline void C_SEARCHDRONE::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void C_SEARCHDRONE::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SEARCHDRONE.y)
}

// float z = 4;
inline void C_SEARCHDRONE::clear_z() {
  _impl_.z_ = 0;
}
inline float C_SEARCHDRONE::_internal_z() const {
  return _impl_.z_;
}
inline float C_SEARCHDRONE::z() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SEARCHDRONE.z)
  return _internal_z();
}
inline void C_SEARCHDRONE::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void C_SEARCHDRONE::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SEARCHDRONE.z)
}

// float yaw = 5;
inline void C_SEARCHDRONE::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float C_SEARCHDRONE::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float C_SEARCHDRONE::yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SEARCHDRONE.yaw)
  return _internal_yaw();
}
inline void C_SEARCHDRONE::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void C_SEARCHDRONE::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SEARCHDRONE.yaw)
}

// float pitch = 6;
inline void C_SEARCHDRONE::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float C_SEARCHDRONE::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float C_SEARCHDRONE::pitch() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SEARCHDRONE.pitch)
  return _internal_pitch();
}
inline void C_SEARCHDRONE::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void C_SEARCHDRONE::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SEARCHDRONE.pitch)
}

// float roll = 7;
inline void C_SEARCHDRONE::clear_roll() {
  _impl_.roll_ = 0;
}
inline float C_SEARCHDRONE::_internal_roll() const {
  return _impl_.roll_;
}
inline float C_SEARCHDRONE::roll() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SEARCHDRONE.roll)
  return _internal_roll();
}
inline void C_SEARCHDRONE::_internal_set_roll(float value) {
  
  _impl_.roll_ = value;
}
inline void C_SEARCHDRONE::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SEARCHDRONE.roll)
}

// -------------------------------------------------------------------

// S_RETURNDRONE

// uint64 object_id = 1;
inline void S_RETURNDRONE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_RETURNDRONE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_RETURNDRONE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_RETURNDRONE.object_id)
  return _internal_object_id();
}
inline void S_RETURNDRONE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_RETURNDRONE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_RETURNDRONE.object_id)
}

// -------------------------------------------------------------------

// C_RETURNDRONE

// uint64 object_id = 1;
inline void C_RETURNDRONE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_RETURNDRONE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_RETURNDRONE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_RETURNDRONE.object_id)
  return _internal_object_id();
}
inline void C_RETURNDRONE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_RETURNDRONE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_RETURNDRONE.object_id)
}

// -------------------------------------------------------------------

// S_ATTACKDRONE

// uint64 object_id = 1;
inline void S_ATTACKDRONE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_ATTACKDRONE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_ATTACKDRONE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ATTACKDRONE.object_id)
  return _internal_object_id();
}
inline void S_ATTACKDRONE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_ATTACKDRONE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ATTACKDRONE.object_id)
}

// -------------------------------------------------------------------

// C_ATTACKDRONE

// uint64 object_id = 1;
inline void C_ATTACKDRONE::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_ATTACKDRONE::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_ATTACKDRONE::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ATTACKDRONE.object_id)
  return _internal_object_id();
}
inline void C_ATTACKDRONE::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_ATTACKDRONE::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ATTACKDRONE.object_id)
}

// -------------------------------------------------------------------

// S_EATITEM_MAXHPUP

// uint64 object_id = 1;
inline void S_EATITEM_MAXHPUP::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_EATITEM_MAXHPUP::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_EATITEM_MAXHPUP::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EATITEM_MAXHPUP.object_id)
  return _internal_object_id();
}
inline void S_EATITEM_MAXHPUP::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_EATITEM_MAXHPUP::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EATITEM_MAXHPUP.object_id)
}

// float maxHP = 2;
inline void S_EATITEM_MAXHPUP::clear_maxhp() {
  _impl_.maxhp_ = 0;
}
inline float S_EATITEM_MAXHPUP::_internal_maxhp() const {
  return _impl_.maxhp_;
}
inline float S_EATITEM_MAXHPUP::maxhp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EATITEM_MAXHPUP.maxHP)
  return _internal_maxhp();
}
inline void S_EATITEM_MAXHPUP::_internal_set_maxhp(float value) {
  
  _impl_.maxhp_ = value;
}
inline void S_EATITEM_MAXHPUP::set_maxhp(float value) {
  _internal_set_maxhp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EATITEM_MAXHPUP.maxHP)
}

// -------------------------------------------------------------------

// C_EATITEM_MAXHPUP

// uint64 object_id = 1;
inline void C_EATITEM_MAXHPUP::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_EATITEM_MAXHPUP::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_EATITEM_MAXHPUP::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EATITEM_MAXHPUP.object_id)
  return _internal_object_id();
}
inline void C_EATITEM_MAXHPUP::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_EATITEM_MAXHPUP::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EATITEM_MAXHPUP.object_id)
}

// float maxHP = 2;
inline void C_EATITEM_MAXHPUP::clear_maxhp() {
  _impl_.maxhp_ = 0;
}
inline float C_EATITEM_MAXHPUP::_internal_maxhp() const {
  return _impl_.maxhp_;
}
inline float C_EATITEM_MAXHPUP::maxhp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EATITEM_MAXHPUP.maxHP)
  return _internal_maxhp();
}
inline void C_EATITEM_MAXHPUP::_internal_set_maxhp(float value) {
  
  _impl_.maxhp_ = value;
}
inline void C_EATITEM_MAXHPUP::set_maxhp(float value) {
  _internal_set_maxhp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EATITEM_MAXHPUP.maxHP)
}

// -------------------------------------------------------------------

// S_EATITEM_LVUP

// uint64 object_id = 1;
inline void S_EATITEM_LVUP::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_EATITEM_LVUP::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_EATITEM_LVUP::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EATITEM_LVUP.object_id)
  return _internal_object_id();
}
inline void S_EATITEM_LVUP::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_EATITEM_LVUP::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EATITEM_LVUP.object_id)
}

// int64 curLV = 2;
inline void S_EATITEM_LVUP::clear_curlv() {
  _impl_.curlv_ = int64_t{0};
}
inline int64_t S_EATITEM_LVUP::_internal_curlv() const {
  return _impl_.curlv_;
}
inline int64_t S_EATITEM_LVUP::curlv() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EATITEM_LVUP.curLV)
  return _internal_curlv();
}
inline void S_EATITEM_LVUP::_internal_set_curlv(int64_t value) {
  
  _impl_.curlv_ = value;
}
inline void S_EATITEM_LVUP::set_curlv(int64_t value) {
  _internal_set_curlv(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EATITEM_LVUP.curLV)
}

// -------------------------------------------------------------------

// C_EATITEM_LVUP

// uint64 object_id = 1;
inline void C_EATITEM_LVUP::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_EATITEM_LVUP::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_EATITEM_LVUP::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EATITEM_LVUP.object_id)
  return _internal_object_id();
}
inline void C_EATITEM_LVUP::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_EATITEM_LVUP::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EATITEM_LVUP.object_id)
}

// int64 curLV = 2;
inline void C_EATITEM_LVUP::clear_curlv() {
  _impl_.curlv_ = int64_t{0};
}
inline int64_t C_EATITEM_LVUP::_internal_curlv() const {
  return _impl_.curlv_;
}
inline int64_t C_EATITEM_LVUP::curlv() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EATITEM_LVUP.curLV)
  return _internal_curlv();
}
inline void C_EATITEM_LVUP::_internal_set_curlv(int64_t value) {
  
  _impl_.curlv_ = value;
}
inline void C_EATITEM_LVUP::set_curlv(int64_t value) {
  _internal_set_curlv(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EATITEM_LVUP.curLV)
}

// -------------------------------------------------------------------

// S_EATITEM_DMGUP

// uint64 object_id = 1;
inline void S_EATITEM_DMGUP::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_EATITEM_DMGUP::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_EATITEM_DMGUP::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EATITEM_DMGUP.object_id)
  return _internal_object_id();
}
inline void S_EATITEM_DMGUP::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_EATITEM_DMGUP::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EATITEM_DMGUP.object_id)
}

// float attackDmg = 2;
inline void S_EATITEM_DMGUP::clear_attackdmg() {
  _impl_.attackdmg_ = 0;
}
inline float S_EATITEM_DMGUP::_internal_attackdmg() const {
  return _impl_.attackdmg_;
}
inline float S_EATITEM_DMGUP::attackdmg() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EATITEM_DMGUP.attackDmg)
  return _internal_attackdmg();
}
inline void S_EATITEM_DMGUP::_internal_set_attackdmg(float value) {
  
  _impl_.attackdmg_ = value;
}
inline void S_EATITEM_DMGUP::set_attackdmg(float value) {
  _internal_set_attackdmg(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EATITEM_DMGUP.attackDmg)
}

// -------------------------------------------------------------------

// C_EATITEM_DMGUP

// uint64 object_id = 1;
inline void C_EATITEM_DMGUP::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_EATITEM_DMGUP::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_EATITEM_DMGUP::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EATITEM_DMGUP.object_id)
  return _internal_object_id();
}
inline void C_EATITEM_DMGUP::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_EATITEM_DMGUP::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EATITEM_DMGUP.object_id)
}

// float attackDmg = 2;
inline void C_EATITEM_DMGUP::clear_attackdmg() {
  _impl_.attackdmg_ = 0;
}
inline float C_EATITEM_DMGUP::_internal_attackdmg() const {
  return _impl_.attackdmg_;
}
inline float C_EATITEM_DMGUP::attackdmg() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EATITEM_DMGUP.attackDmg)
  return _internal_attackdmg();
}
inline void C_EATITEM_DMGUP::_internal_set_attackdmg(float value) {
  
  _impl_.attackdmg_ = value;
}
inline void C_EATITEM_DMGUP::set_attackdmg(float value) {
  _internal_set_attackdmg(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EATITEM_DMGUP.attackDmg)
}

// -------------------------------------------------------------------

// S_EATITEM_HEALHP

// uint64 object_id = 1;
inline void S_EATITEM_HEALHP::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_EATITEM_HEALHP::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_EATITEM_HEALHP::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EATITEM_HEALHP.object_id)
  return _internal_object_id();
}
inline void S_EATITEM_HEALHP::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_EATITEM_HEALHP::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EATITEM_HEALHP.object_id)
}

// float curHP = 2;
inline void S_EATITEM_HEALHP::clear_curhp() {
  _impl_.curhp_ = 0;
}
inline float S_EATITEM_HEALHP::_internal_curhp() const {
  return _impl_.curhp_;
}
inline float S_EATITEM_HEALHP::curhp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EATITEM_HEALHP.curHP)
  return _internal_curhp();
}
inline void S_EATITEM_HEALHP::_internal_set_curhp(float value) {
  
  _impl_.curhp_ = value;
}
inline void S_EATITEM_HEALHP::set_curhp(float value) {
  _internal_set_curhp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EATITEM_HEALHP.curHP)
}

// -------------------------------------------------------------------

// C_EATITEM_HEALHP

// uint64 object_id = 1;
inline void C_EATITEM_HEALHP::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_EATITEM_HEALHP::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_EATITEM_HEALHP::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EATITEM_HEALHP.object_id)
  return _internal_object_id();
}
inline void C_EATITEM_HEALHP::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_EATITEM_HEALHP::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EATITEM_HEALHP.object_id)
}

// float curHP = 2;
inline void C_EATITEM_HEALHP::clear_curhp() {
  _impl_.curhp_ = 0;
}
inline float C_EATITEM_HEALHP::_internal_curhp() const {
  return _impl_.curhp_;
}
inline float C_EATITEM_HEALHP::curhp() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EATITEM_HEALHP.curHP)
  return _internal_curhp();
}
inline void C_EATITEM_HEALHP::_internal_set_curhp(float value) {
  
  _impl_.curhp_ = value;
}
inline void C_EATITEM_HEALHP::set_curhp(float value) {
  _internal_set_curhp(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EATITEM_HEALHP.curHP)
}

// -------------------------------------------------------------------

// S_SET_MAGNETICFIELD

// float r = 1;
inline void S_SET_MAGNETICFIELD::clear_r() {
  _impl_.r_ = 0;
}
inline float S_SET_MAGNETICFIELD::_internal_r() const {
  return _impl_.r_;
}
inline float S_SET_MAGNETICFIELD::r() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SET_MAGNETICFIELD.r)
  return _internal_r();
}
inline void S_SET_MAGNETICFIELD::_internal_set_r(float value) {
  
  _impl_.r_ = value;
}
inline void S_SET_MAGNETICFIELD::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SET_MAGNETICFIELD.r)
}

// float g = 2;
inline void S_SET_MAGNETICFIELD::clear_g() {
  _impl_.g_ = 0;
}
inline float S_SET_MAGNETICFIELD::_internal_g() const {
  return _impl_.g_;
}
inline float S_SET_MAGNETICFIELD::g() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SET_MAGNETICFIELD.g)
  return _internal_g();
}
inline void S_SET_MAGNETICFIELD::_internal_set_g(float value) {
  
  _impl_.g_ = value;
}
inline void S_SET_MAGNETICFIELD::set_g(float value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SET_MAGNETICFIELD.g)
}

// float b = 3;
inline void S_SET_MAGNETICFIELD::clear_b() {
  _impl_.b_ = 0;
}
inline float S_SET_MAGNETICFIELD::_internal_b() const {
  return _impl_.b_;
}
inline float S_SET_MAGNETICFIELD::b() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SET_MAGNETICFIELD.b)
  return _internal_b();
}
inline void S_SET_MAGNETICFIELD::_internal_set_b(float value) {
  
  _impl_.b_ = value;
}
inline void S_SET_MAGNETICFIELD::set_b(float value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SET_MAGNETICFIELD.b)
}

// float a = 4;
inline void S_SET_MAGNETICFIELD::clear_a() {
  _impl_.a_ = 0;
}
inline float S_SET_MAGNETICFIELD::_internal_a() const {
  return _impl_.a_;
}
inline float S_SET_MAGNETICFIELD::a() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SET_MAGNETICFIELD.a)
  return _internal_a();
}
inline void S_SET_MAGNETICFIELD::_internal_set_a(float value) {
  
  _impl_.a_ = value;
}
inline void S_SET_MAGNETICFIELD::set_a(float value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SET_MAGNETICFIELD.a)
}

// float radius = 5;
inline void S_SET_MAGNETICFIELD::clear_radius() {
  _impl_.radius_ = 0;
}
inline float S_SET_MAGNETICFIELD::_internal_radius() const {
  return _impl_.radius_;
}
inline float S_SET_MAGNETICFIELD::radius() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SET_MAGNETICFIELD.radius)
  return _internal_radius();
}
inline void S_SET_MAGNETICFIELD::_internal_set_radius(float value) {
  
  _impl_.radius_ = value;
}
inline void S_SET_MAGNETICFIELD::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SET_MAGNETICFIELD.radius)
}

// float time = 6;
inline void S_SET_MAGNETICFIELD::clear_time() {
  _impl_.time_ = 0;
}
inline float S_SET_MAGNETICFIELD::_internal_time() const {
  return _impl_.time_;
}
inline float S_SET_MAGNETICFIELD::time() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SET_MAGNETICFIELD.time)
  return _internal_time();
}
inline void S_SET_MAGNETICFIELD::_internal_set_time(float value) {
  
  _impl_.time_ = value;
}
inline void S_SET_MAGNETICFIELD::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SET_MAGNETICFIELD.time)
}

// -------------------------------------------------------------------

// C_SET_MAGNETICFIELD

// float r = 1;
inline void C_SET_MAGNETICFIELD::clear_r() {
  _impl_.r_ = 0;
}
inline float C_SET_MAGNETICFIELD::_internal_r() const {
  return _impl_.r_;
}
inline float C_SET_MAGNETICFIELD::r() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SET_MAGNETICFIELD.r)
  return _internal_r();
}
inline void C_SET_MAGNETICFIELD::_internal_set_r(float value) {
  
  _impl_.r_ = value;
}
inline void C_SET_MAGNETICFIELD::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SET_MAGNETICFIELD.r)
}

// float g = 2;
inline void C_SET_MAGNETICFIELD::clear_g() {
  _impl_.g_ = 0;
}
inline float C_SET_MAGNETICFIELD::_internal_g() const {
  return _impl_.g_;
}
inline float C_SET_MAGNETICFIELD::g() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SET_MAGNETICFIELD.g)
  return _internal_g();
}
inline void C_SET_MAGNETICFIELD::_internal_set_g(float value) {
  
  _impl_.g_ = value;
}
inline void C_SET_MAGNETICFIELD::set_g(float value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SET_MAGNETICFIELD.g)
}

// float b = 3;
inline void C_SET_MAGNETICFIELD::clear_b() {
  _impl_.b_ = 0;
}
inline float C_SET_MAGNETICFIELD::_internal_b() const {
  return _impl_.b_;
}
inline float C_SET_MAGNETICFIELD::b() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SET_MAGNETICFIELD.b)
  return _internal_b();
}
inline void C_SET_MAGNETICFIELD::_internal_set_b(float value) {
  
  _impl_.b_ = value;
}
inline void C_SET_MAGNETICFIELD::set_b(float value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SET_MAGNETICFIELD.b)
}

// float a = 4;
inline void C_SET_MAGNETICFIELD::clear_a() {
  _impl_.a_ = 0;
}
inline float C_SET_MAGNETICFIELD::_internal_a() const {
  return _impl_.a_;
}
inline float C_SET_MAGNETICFIELD::a() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SET_MAGNETICFIELD.a)
  return _internal_a();
}
inline void C_SET_MAGNETICFIELD::_internal_set_a(float value) {
  
  _impl_.a_ = value;
}
inline void C_SET_MAGNETICFIELD::set_a(float value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SET_MAGNETICFIELD.a)
}

// float radius = 5;
inline void C_SET_MAGNETICFIELD::clear_radius() {
  _impl_.radius_ = 0;
}
inline float C_SET_MAGNETICFIELD::_internal_radius() const {
  return _impl_.radius_;
}
inline float C_SET_MAGNETICFIELD::radius() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SET_MAGNETICFIELD.radius)
  return _internal_radius();
}
inline void C_SET_MAGNETICFIELD::_internal_set_radius(float value) {
  
  _impl_.radius_ = value;
}
inline void C_SET_MAGNETICFIELD::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SET_MAGNETICFIELD.radius)
}

// float time = 6;
inline void C_SET_MAGNETICFIELD::clear_time() {
  _impl_.time_ = 0;
}
inline float C_SET_MAGNETICFIELD::_internal_time() const {
  return _impl_.time_;
}
inline float C_SET_MAGNETICFIELD::time() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SET_MAGNETICFIELD.time)
  return _internal_time();
}
inline void C_SET_MAGNETICFIELD::_internal_set_time(float value) {
  
  _impl_.time_ = value;
}
inline void C_SET_MAGNETICFIELD::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SET_MAGNETICFIELD.time)
}

// -------------------------------------------------------------------

// S_WORLD_LVUP

// int64 worldLevel = 1;
inline void S_WORLD_LVUP::clear_worldlevel() {
  _impl_.worldlevel_ = int64_t{0};
}
inline int64_t S_WORLD_LVUP::_internal_worldlevel() const {
  return _impl_.worldlevel_;
}
inline int64_t S_WORLD_LVUP::worldlevel() const {
  // @@protoc_insertion_point(field_get:Protocol.S_WORLD_LVUP.worldLevel)
  return _internal_worldlevel();
}
inline void S_WORLD_LVUP::_internal_set_worldlevel(int64_t value) {
  
  _impl_.worldlevel_ = value;
}
inline void S_WORLD_LVUP::set_worldlevel(int64_t value) {
  _internal_set_worldlevel(value);
  // @@protoc_insertion_point(field_set:Protocol.S_WORLD_LVUP.worldLevel)
}

// -------------------------------------------------------------------

// C_WORLD_LVUP

// int64 worldLevel = 1;
inline void C_WORLD_LVUP::clear_worldlevel() {
  _impl_.worldlevel_ = int64_t{0};
}
inline int64_t C_WORLD_LVUP::_internal_worldlevel() const {
  return _impl_.worldlevel_;
}
inline int64_t C_WORLD_LVUP::worldlevel() const {
  // @@protoc_insertion_point(field_get:Protocol.C_WORLD_LVUP.worldLevel)
  return _internal_worldlevel();
}
inline void C_WORLD_LVUP::_internal_set_worldlevel(int64_t value) {
  
  _impl_.worldlevel_ = value;
}
inline void C_WORLD_LVUP::set_worldlevel(int64_t value) {
  _internal_set_worldlevel(value);
  // @@protoc_insertion_point(field_set:Protocol.C_WORLD_LVUP.worldLevel)
}

// -------------------------------------------------------------------

// S_GAMERESULT

// uint64 object_id = 1;
inline void S_GAMERESULT::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_GAMERESULT::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_GAMERESULT::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GAMERESULT.object_id)
  return _internal_object_id();
}
inline void S_GAMERESULT::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_GAMERESULT::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_GAMERESULT.object_id)
}

// -------------------------------------------------------------------

// C_GAMERESULT

// uint64 object_id = 1;
inline void C_GAMERESULT::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_GAMERESULT::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_GAMERESULT::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_GAMERESULT.object_id)
  return _internal_object_id();
}
inline void C_GAMERESULT::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_GAMERESULT::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_GAMERESULT.object_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
